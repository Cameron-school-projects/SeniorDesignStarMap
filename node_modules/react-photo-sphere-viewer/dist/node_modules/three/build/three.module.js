var _COLOR_SPACES;
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
var REVISION = '161';
var FrontSide = 0;
var BackSide = 1;
var NormalBlending = 1;
var AdditiveBlending = 2;
var AddEquation = 100;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var LessEqualDepth = 3;
var MultiplyOperation = 0;
var UVMapping = 300;
var RepeatWrapping = 1000;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var LinearFilter = 1006;
var LinearMipmapLinearFilter = 1008;
var UnsignedByteType = 1009;
var UnsignedIntType = 1014;
var FloatType = 1015;
var UnsignedInt248Type = 1020;
var RGBAFormat = 1023;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
/** @deprecated Use LinearSRGBColorSpace or NoColorSpace in three.js r152+. */
var LinearEncoding = 3000;
/** @deprecated Use SRGBColorSpace in three.js r152+. */
var sRGBEncoding = 3001;

// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
var NoColorSpace = '';
var SRGBColorSpace = 'srgb';
var LinearSRGBColorSpace = 'srgb-linear';
var DisplayP3ColorSpace = 'display-p3';
var LinearDisplayP3ColorSpace = 'display-p3-linear';
var LinearTransfer = 'linear';
var SRGBTransfer = 'srgb';
var Rec709Primaries = 'rec709';
var P3Primaries = 'p3';
var KeepStencilOp = 7680;
var AlwaysStencilFunc = 519;
var LessEqualCompare = 515;
var StaticDrawUsage = 35044;
var WebGLCoordinateSystem = 2000;
var WebGPUCoordinateSystem = 2001;

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */
var EventDispatcher = /*#__PURE__*/function () {
  function EventDispatcher() {
    _classCallCheck(this, EventDispatcher);
  }
  _createClass(EventDispatcher, [{
    key: "addEventListener",
    value: function addEventListener(type, listener) {
      if (this._listeners === undefined) this._listeners = {};
      var listeners = this._listeners;
      if (listeners[type] === undefined) {
        listeners[type] = [];
      }
      if (listeners[type].indexOf(listener) === -1) {
        listeners[type].push(listener);
      }
    }
  }, {
    key: "hasEventListener",
    value: function hasEventListener(type, listener) {
      if (this._listeners === undefined) return false;
      var listeners = this._listeners;
      return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener) {
      if (this._listeners === undefined) return;
      var listeners = this._listeners;
      var listenerArray = listeners[type];
      if (listenerArray !== undefined) {
        var index = listenerArray.indexOf(listener);
        if (index !== -1) {
          listenerArray.splice(index, 1);
        }
      }
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      if (this._listeners === undefined) return;
      var listeners = this._listeners;
      var listenerArray = listeners[event.type];
      if (listenerArray !== undefined) {
        event.target = this;

        // Make a copy, in case listeners are removed while iterating.
        var array = listenerArray.slice(0);
        for (var i = 0, l = array.length; i < l; i++) {
          array[i].call(this, event);
        }
        event.target = null;
      }
    }
  }]);
  return EventDispatcher;
}();
var _lut = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff'];
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;

// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function generateUUID() {
  var d0 = Math.random() * 0xffffffff | 0;
  var d1 = Math.random() * 0xffffffff | 0;
  var d2 = Math.random() * 0xffffffff | 0;
  var d3 = Math.random() * 0xffffffff | 0;
  var uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];

  // .toLowerCase() here flattens concatenated strings to save heap memory space.
  return uuid.toLowerCase();
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

// compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function euclideanModulo(n, m) {
  return (n % m + m) % m;
}

// https://en.wikipedia.org/wiki/Linear_interpolation
function lerp(x, y, t) {
  return (1 - t) * x + t * y;
}
function denormalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return value / 4294967295.0;
    case Uint16Array:
      return value / 65535.0;
    case Uint8Array:
      return value / 255.0;
    case Int32Array:
      return Math.max(value / 2147483647.0, -1.0);
    case Int16Array:
      return Math.max(value / 32767.0, -1.0);
    case Int8Array:
      return Math.max(value / 127.0, -1.0);
    default:
      throw new Error('Invalid component type.');
  }
}
function normalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return Math.round(value * 4294967295.0);
    case Uint16Array:
      return Math.round(value * 65535.0);
    case Uint8Array:
      return Math.round(value * 255.0);
    case Int32Array:
      return Math.round(value * 2147483647.0);
    case Int16Array:
      return Math.round(value * 32767.0);
    case Int8Array:
      return Math.round(value * 127.0);
    default:
      throw new Error('Invalid component type.');
  }
}
var Vector2 = /*#__PURE__*/function (_Symbol$iterator) {
  function Vector2() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    _classCallCheck(this, Vector2);
    Vector2.prototype.isVector2 = true;
    this.x = x;
    this.y = y;
  }
  _createClass(Vector2, [{
    key: "width",
    get: function get() {
      return this.x;
    },
    set: function set(value) {
      this.x = value;
    }
  }, {
    key: "height",
    get: function get() {
      return this.y;
    },
    set: function set(value) {
      this.y = value;
    }
  }, {
    key: "set",
    value: function set(x, y) {
      this.x = x;
      this.y = y;
      return this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      return this;
    }
  }, {
    key: "setX",
    value: function setX(x) {
      this.x = x;
      return this;
    }
  }, {
    key: "setY",
    value: function setY(y) {
      this.y = y;
      return this;
    }
  }, {
    key: "setComponent",
    value: function setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        default:
          throw new Error('index is out of range: ' + index);
      }
      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error('index is out of range: ' + index);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.x, this.y);
    }
  }, {
    key: "copy",
    value: function copy(v) {
      this.x = v.x;
      this.y = v.y;
      return this;
    }
  }, {
    key: "add",
    value: function add(v) {
      this.x += v.x;
      this.y += v.y;
      return this;
    }
  }, {
    key: "addScalar",
    value: function addScalar(s) {
      this.x += s;
      this.y += s;
      return this;
    }
  }, {
    key: "addVectors",
    value: function addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      return this;
    }
  }, {
    key: "addScaledVector",
    value: function addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      return this;
    }
  }, {
    key: "sub",
    value: function sub(v) {
      this.x -= v.x;
      this.y -= v.y;
      return this;
    }
  }, {
    key: "subScalar",
    value: function subScalar(s) {
      this.x -= s;
      this.y -= s;
      return this;
    }
  }, {
    key: "subVectors",
    value: function subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      return this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    }
  }, {
    key: "divide",
    value: function divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      return this;
    }
  }, {
    key: "divideScalar",
    value: function divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
  }, {
    key: "applyMatrix3",
    value: function applyMatrix3(m) {
      var x = this.x,
        y = this.y;
      var e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6];
      this.y = e[1] * x + e[4] * y + e[7];
      return this;
    }
  }, {
    key: "min",
    value: function min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      return this;
    }
  }, {
    key: "max",
    value: function max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      return this;
    }
  }, {
    key: "clamp",
    value: function clamp(min, max) {
      // assumes min < max, componentwise

      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      return this;
    }
  }, {
    key: "clampScalar",
    value: function clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      return this;
    }
  }, {
    key: "clampLength",
    value: function clampLength(min, max) {
      var length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
  }, {
    key: "floor",
    value: function floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    }
  }, {
    key: "ceil",
    value: function ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    }
  }, {
    key: "round",
    value: function round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    }
  }, {
    key: "roundToZero",
    value: function roundToZero() {
      this.x = Math.trunc(this.x);
      this.y = Math.trunc(this.y);
      return this;
    }
  }, {
    key: "negate",
    value: function negate() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    }
  }, {
    key: "dot",
    value: function dot(v) {
      return this.x * v.x + this.y * v.y;
    }
  }, {
    key: "cross",
    value: function cross(v) {
      return this.x * v.y - this.y * v.x;
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
  }, {
    key: "manhattanLength",
    value: function manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      return this.divideScalar(this.length() || 1);
    }
  }, {
    key: "angle",
    value: function angle() {
      // computes the angle in radians with respect to the positive x-axis

      var angle = Math.atan2(-this.y, -this.x) + Math.PI;
      return angle;
    }
  }, {
    key: "angleTo",
    value: function angleTo(v) {
      var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
      if (denominator === 0) return Math.PI / 2;
      var theta = this.dot(v) / denominator;

      // clamp, to handle numerical problems

      return Math.acos(clamp(theta, -1, 1));
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
  }, {
    key: "distanceToSquared",
    value: function distanceToSquared(v) {
      var dx = this.x - v.x,
        dy = this.y - v.y;
      return dx * dx + dy * dy;
    }
  }, {
    key: "manhattanDistanceTo",
    value: function manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    }
  }, {
    key: "setLength",
    value: function setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
  }, {
    key: "lerp",
    value: function lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      return this;
    }
  }, {
    key: "lerpVectors",
    value: function lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      return this;
    }
  }, {
    key: "equals",
    value: function equals(v) {
      return v.x === this.x && v.y === this.y;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.x = array[offset];
      this.y = array[offset + 1];
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this.x;
      array[offset + 1] = this.y;
      return array;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(attribute, index) {
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      return this;
    }
  }, {
    key: "rotateAround",
    value: function rotateAround(center, angle) {
      var c = Math.cos(angle),
        s = Math.sin(angle);
      var x = this.x - center.x;
      var y = this.y - center.y;
      this.x = x * c - y * s + center.x;
      this.y = x * s + y * c + center.y;
      return this;
    }
  }, {
    key: "random",
    value: function random() {
      this.x = Math.random();
      this.y = Math.random();
      return this;
    }
  }, {
    key: _Symbol$iterator,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      return _regeneratorRuntime().wrap(function value$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return this.x;
          case 2:
            _context.next = 4;
            return this.y;
          case 4:
          case "end":
            return _context.stop();
        }
      }, value, this);
    })
  }]);
  return Vector2;
}(Symbol.iterator);
var Matrix3 = /*#__PURE__*/function () {
  function Matrix3(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    _classCallCheck(this, Matrix3);
    Matrix3.prototype.isMatrix3 = true;
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (n11 !== undefined) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }
  _createClass(Matrix3, [{
    key: "set",
    value: function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      var te = this.elements;
      te[0] = n11;
      te[1] = n21;
      te[2] = n31;
      te[3] = n12;
      te[4] = n22;
      te[5] = n32;
      te[6] = n13;
      te[7] = n23;
      te[8] = n33;
      return this;
    }
  }, {
    key: "identity",
    value: function identity() {
      this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(m) {
      var te = this.elements;
      var me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      return this;
    }
  }, {
    key: "extractBasis",
    value: function extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrix3Column(this, 0);
      yAxis.setFromMatrix3Column(this, 1);
      zAxis.setFromMatrix3Column(this, 2);
      return this;
    }
  }, {
    key: "setFromMatrix4",
    value: function setFromMatrix4(m) {
      var me = m.elements;
      this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(m) {
      return this.multiplyMatrices(this, m);
    }
  }, {
    key: "premultiply",
    value: function premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
  }, {
    key: "multiplyMatrices",
    value: function multiplyMatrices(a, b) {
      var ae = a.elements;
      var be = b.elements;
      var te = this.elements;
      var a11 = ae[0],
        a12 = ae[3],
        a13 = ae[6];
      var a21 = ae[1],
        a22 = ae[4],
        a23 = ae[7];
      var a31 = ae[2],
        a32 = ae[5],
        a33 = ae[8];
      var b11 = be[0],
        b12 = be[3],
        b13 = be[6];
      var b21 = be[1],
        b22 = be[4],
        b23 = be[7];
      var b31 = be[2],
        b32 = be[5],
        b33 = be[8];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31;
      te[3] = a11 * b12 + a12 * b22 + a13 * b32;
      te[6] = a11 * b13 + a12 * b23 + a13 * b33;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31;
      te[4] = a21 * b12 + a22 * b22 + a23 * b32;
      te[7] = a21 * b13 + a22 * b23 + a23 * b33;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31;
      te[5] = a31 * b12 + a32 * b22 + a33 * b32;
      te[8] = a31 * b13 + a32 * b23 + a33 * b33;
      return this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(s) {
      var te = this.elements;
      te[0] *= s;
      te[3] *= s;
      te[6] *= s;
      te[1] *= s;
      te[4] *= s;
      te[7] *= s;
      te[2] *= s;
      te[5] *= s;
      te[8] *= s;
      return this;
    }
  }, {
    key: "determinant",
    value: function determinant() {
      var te = this.elements;
      var a = te[0],
        b = te[1],
        c = te[2],
        d = te[3],
        e = te[4],
        f = te[5],
        g = te[6],
        h = te[7],
        i = te[8];
      return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    }
  }, {
    key: "invert",
    value: function invert() {
      var te = this.elements,
        n11 = te[0],
        n21 = te[1],
        n31 = te[2],
        n12 = te[3],
        n22 = te[4],
        n32 = te[5],
        n13 = te[6],
        n23 = te[7],
        n33 = te[8],
        t11 = n33 * n22 - n32 * n23,
        t12 = n32 * n13 - n33 * n12,
        t13 = n23 * n12 - n22 * n13,
        det = n11 * t11 + n21 * t12 + n31 * t13;
      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      var detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n31 * n23 - n33 * n21) * detInv;
      te[2] = (n32 * n21 - n31 * n22) * detInv;
      te[3] = t12 * detInv;
      te[4] = (n33 * n11 - n31 * n13) * detInv;
      te[5] = (n31 * n12 - n32 * n11) * detInv;
      te[6] = t13 * detInv;
      te[7] = (n21 * n13 - n23 * n11) * detInv;
      te[8] = (n22 * n11 - n21 * n12) * detInv;
      return this;
    }
  }, {
    key: "transpose",
    value: function transpose() {
      var tmp;
      var m = this.elements;
      tmp = m[1];
      m[1] = m[3];
      m[3] = tmp;
      tmp = m[2];
      m[2] = m[6];
      m[6] = tmp;
      tmp = m[5];
      m[5] = m[7];
      m[7] = tmp;
      return this;
    }
  }, {
    key: "getNormalMatrix",
    value: function getNormalMatrix(matrix4) {
      return this.setFromMatrix4(matrix4).invert().transpose();
    }
  }, {
    key: "transposeIntoArray",
    value: function transposeIntoArray(r) {
      var m = this.elements;
      r[0] = m[0];
      r[1] = m[3];
      r[2] = m[6];
      r[3] = m[1];
      r[4] = m[4];
      r[5] = m[7];
      r[6] = m[2];
      r[7] = m[5];
      r[8] = m[8];
      return this;
    }
  }, {
    key: "setUvTransform",
    value: function setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
      var c = Math.cos(rotation);
      var s = Math.sin(rotation);
      this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
      return this;
    }

    //
  }, {
    key: "scale",
    value: function scale(sx, sy) {
      this.premultiply(_m3.makeScale(sx, sy));
      return this;
    }
  }, {
    key: "rotate",
    value: function rotate(theta) {
      this.premultiply(_m3.makeRotation(-theta));
      return this;
    }
  }, {
    key: "translate",
    value: function translate(tx, ty) {
      this.premultiply(_m3.makeTranslation(tx, ty));
      return this;
    }

    // for 2D Transforms
  }, {
    key: "makeTranslation",
    value: function makeTranslation(x, y) {
      if (x.isVector2) {
        this.set(1, 0, x.x, 0, 1, x.y, 0, 0, 1);
      } else {
        this.set(1, 0, x, 0, 1, y, 0, 0, 1);
      }
      return this;
    }
  }, {
    key: "makeRotation",
    value: function makeRotation(theta) {
      // counterclockwise

      var c = Math.cos(theta);
      var s = Math.sin(theta);
      this.set(c, -s, 0, s, c, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "makeScale",
    value: function makeScale(x, y) {
      this.set(x, 0, 0, 0, y, 0, 0, 0, 1);
      return this;
    }

    //
  }, {
    key: "equals",
    value: function equals(matrix) {
      var te = this.elements;
      var me = matrix.elements;
      for (var i = 0; i < 9; i++) {
        if (te[i] !== me[i]) return false;
      }
      return true;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      for (var i = 0; i < 9; i++) {
        this.elements[i] = array[i + offset];
      }
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      return array;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }]);
  return Matrix3;
}();
var _m3 = /*@__PURE__*/new Matrix3();
function arrayNeedsUint32(array) {
  // assumes larger values usually on last

  for (var i = array.length - 1; i >= 0; --i) {
    if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
  }

  return false;
}
function createElementNS(name) {
  return document.createElementNS('http://www.w3.org/1999/xhtml', name);
}
var _cache = {};
function warnOnce(message) {
  if (message in _cache) return;
  _cache[message] = true;
  console.warn(message);
}

/**
 * Matrices converting P3 <-> Rec. 709 primaries, without gamut mapping
 * or clipping. Based on W3C specifications for sRGB and Display P3,
 * and ICC specifications for the D50 connection space. Values in/out
 * are _linear_ sRGB and _linear_ Display P3.
 *
 * Note that both sRGB and Display P3 use the sRGB transfer functions.
 *
 * Reference:
 * - http://www.russellcottrell.com/photo/matrixCalculator.htm
 */

var LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /*@__PURE__*/new Matrix3().set(0.8224621, 0.177538, 0.0, 0.0331941, 0.9668058, 0.0, 0.0170827, 0.0723974, 0.9105199);
var LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /*@__PURE__*/new Matrix3().set(1.2249401, -0.2249404, 0.0, -0.0420569, 1.0420571, 0.0, -0.0196376, -0.0786361, 1.0982735);

/**
 * Defines supported color spaces by transfer function and primaries,
 * and provides conversions to/from the Linear-sRGB reference space.
 */
var COLOR_SPACES = (_COLOR_SPACES = {}, _defineProperty(_COLOR_SPACES, LinearSRGBColorSpace, {
  transfer: LinearTransfer,
  primaries: Rec709Primaries,
  toReference: function toReference(color) {
    return color;
  },
  fromReference: function fromReference(color) {
    return color;
  }
}), _defineProperty(_COLOR_SPACES, SRGBColorSpace, {
  transfer: SRGBTransfer,
  primaries: Rec709Primaries,
  toReference: function toReference(color) {
    return color.convertSRGBToLinear();
  },
  fromReference: function fromReference(color) {
    return color.convertLinearToSRGB();
  }
}), _defineProperty(_COLOR_SPACES, LinearDisplayP3ColorSpace, {
  transfer: LinearTransfer,
  primaries: P3Primaries,
  toReference: function toReference(color) {
    return color.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB);
  },
  fromReference: function fromReference(color) {
    return color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3);
  }
}), _defineProperty(_COLOR_SPACES, DisplayP3ColorSpace, {
  transfer: SRGBTransfer,
  primaries: P3Primaries,
  toReference: function toReference(color) {
    return color.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB);
  },
  fromReference: function fromReference(color) {
    return color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB();
  }
}), _COLOR_SPACES);
var SUPPORTED_WORKING_COLOR_SPACES = new Set([LinearSRGBColorSpace, LinearDisplayP3ColorSpace]);
var ColorManagement = {
  enabled: true,
  _workingColorSpace: LinearSRGBColorSpace,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(colorSpace) {
    if (!SUPPORTED_WORKING_COLOR_SPACES.has(colorSpace)) {
      throw new Error("Unsupported working color space, \"".concat(colorSpace, "\"."));
    }
    this._workingColorSpace = colorSpace;
  },
  convert: function convert(color, sourceColorSpace, targetColorSpace) {
    if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
      return color;
    }
    var sourceToReference = COLOR_SPACES[sourceColorSpace].toReference;
    var targetFromReference = COLOR_SPACES[targetColorSpace].fromReference;
    return targetFromReference(sourceToReference(color));
  },
  fromWorkingColorSpace: function fromWorkingColorSpace(color, targetColorSpace) {
    return this.convert(color, this._workingColorSpace, targetColorSpace);
  },
  toWorkingColorSpace: function toWorkingColorSpace(color, sourceColorSpace) {
    return this.convert(color, sourceColorSpace, this._workingColorSpace);
  },
  getPrimaries: function getPrimaries(colorSpace) {
    return COLOR_SPACES[colorSpace].primaries;
  },
  getTransfer: function getTransfer(colorSpace) {
    if (colorSpace === NoColorSpace) return LinearTransfer;
    return COLOR_SPACES[colorSpace].transfer;
  }
};
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
var _canvas;
var ImageUtils = /*#__PURE__*/function () {
  function ImageUtils() {
    _classCallCheck(this, ImageUtils);
  }
  _createClass(ImageUtils, null, [{
    key: "getDataURL",
    value: function getDataURL(image) {
      if (/^data:/i.test(image.src)) {
        return image.src;
      }
      if (typeof HTMLCanvasElement === 'undefined') {
        return image.src;
      }
      var canvas;
      if (image instanceof HTMLCanvasElement) {
        canvas = image;
      } else {
        if (_canvas === undefined) _canvas = createElementNS('canvas');
        _canvas.width = image.width;
        _canvas.height = image.height;
        var context = _canvas.getContext('2d');
        if (image instanceof ImageData) {
          context.putImageData(image, 0, 0);
        } else {
          context.drawImage(image, 0, 0, image.width, image.height);
        }
        canvas = _canvas;
      }
      if (canvas.width > 2048 || canvas.height > 2048) {
        console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);
        return canvas.toDataURL('image/jpeg', 0.6);
      } else {
        return canvas.toDataURL('image/png');
      }
    }
  }, {
    key: "sRGBToLinear",
    value: function sRGBToLinear(image) {
      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
        var canvas = createElementNS('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        var context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, image.width, image.height);
        var imageData = context.getImageData(0, 0, image.width, image.height);
        var data = imageData.data;
        for (var i = 0; i < data.length; i++) {
          data[i] = SRGBToLinear(data[i] / 255) * 255;
        }
        context.putImageData(imageData, 0, 0);
        return canvas;
      } else if (image.data) {
        var _data = image.data.slice(0);
        for (var _i = 0; _i < _data.length; _i++) {
          if (_data instanceof Uint8Array || _data instanceof Uint8ClampedArray) {
            _data[_i] = Math.floor(SRGBToLinear(_data[_i] / 255) * 255);
          } else {
            // assuming float

            _data[_i] = SRGBToLinear(_data[_i]);
          }
        }
        return {
          data: _data,
          width: image.width,
          height: image.height
        };
      } else {
        console.warn('THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.');
        return image;
      }
    }
  }]);
  return ImageUtils;
}();
var _sourceId = 0;
var Source = /*#__PURE__*/function () {
  function Source() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    _classCallCheck(this, Source);
    this.isSource = true;
    Object.defineProperty(this, 'id', {
      value: _sourceId++
    });
    this.uuid = generateUUID();
    this.data = data;
    this.dataReady = true;
    this.version = 0;
  }
  _createClass(Source, [{
    key: "needsUpdate",
    set: function set(value) {
      if (value === true) this.version++;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var isRootObject = meta === undefined || typeof meta === 'string';
      if (!isRootObject && meta.images[this.uuid] !== undefined) {
        return meta.images[this.uuid];
      }
      var output = {
        uuid: this.uuid,
        url: ''
      };
      var data = this.data;
      if (data !== null) {
        var url;
        if (Array.isArray(data)) {
          // cube texture

          url = [];
          for (var i = 0, l = data.length; i < l; i++) {
            if (data[i].isDataTexture) {
              url.push(serializeImage(data[i].image));
            } else {
              url.push(serializeImage(data[i]));
            }
          }
        } else {
          // texture

          url = serializeImage(data);
        }
        output.url = url;
      }
      if (!isRootObject) {
        meta.images[this.uuid] = output;
      }
      return output;
    }
  }]);
  return Source;
}();
function serializeImage(image) {
  if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
    // default images

    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      // images of DataTexture

      return {
        data: Array.from(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn('THREE.Texture: Unable to serialize Texture.');
      return {};
    }
  }
}
var _textureId = 0;
var Texture = /*#__PURE__*/function (_EventDispatcher) {
  _inherits(Texture, _EventDispatcher);
  var _super = _createSuper(Texture);
  function Texture() {
    var _this;
    var image = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Texture.DEFAULT_IMAGE;
    var mapping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Texture.DEFAULT_MAPPING;
    var wrapS = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ClampToEdgeWrapping;
    var wrapT = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ClampToEdgeWrapping;
    var magFilter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : LinearFilter;
    var minFilter = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : LinearMipmapLinearFilter;
    var format = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : RGBAFormat;
    var type = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : UnsignedByteType;
    var anisotropy = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : Texture.DEFAULT_ANISOTROPY;
    var colorSpace = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : NoColorSpace;
    _classCallCheck(this, Texture);
    _this = _super.call(this);
    _this.isTexture = true;
    Object.defineProperty(_assertThisInitialized(_this), 'id', {
      value: _textureId++
    });
    _this.uuid = generateUUID();
    _this.name = '';
    _this.source = new Source(image);
    _this.mipmaps = [];
    _this.mapping = mapping;
    _this.channel = 0;
    _this.wrapS = wrapS;
    _this.wrapT = wrapT;
    _this.magFilter = magFilter;
    _this.minFilter = minFilter;
    _this.anisotropy = anisotropy;
    _this.format = format;
    _this.internalFormat = null;
    _this.type = type;
    _this.offset = new Vector2(0, 0);
    _this.repeat = new Vector2(1, 1);
    _this.center = new Vector2(0, 0);
    _this.rotation = 0;
    _this.matrixAutoUpdate = true;
    _this.matrix = new Matrix3();
    _this.generateMipmaps = true;
    _this.premultiplyAlpha = false;
    _this.flipY = true;
    _this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

    if (typeof colorSpace === 'string') {
      _this.colorSpace = colorSpace;
    } else {
      // @deprecated, r152

      warnOnce('THREE.Texture: Property .encoding has been replaced by .colorSpace.');
      _this.colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
    }
    _this.userData = {};
    _this.version = 0;
    _this.onUpdate = null;
    _this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
    _this.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)
    return _this;
  }
  _createClass(Texture, [{
    key: "image",
    get: function get() {
      return this.source.data;
    },
    set: function set() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.source.data = value;
    }
  }, {
    key: "updateMatrix",
    value: function updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.name = source.name;
      this.source = source.source;
      this.mipmaps = source.mipmaps.slice(0);
      this.mapping = source.mapping;
      this.channel = source.channel;
      this.wrapS = source.wrapS;
      this.wrapT = source.wrapT;
      this.magFilter = source.magFilter;
      this.minFilter = source.minFilter;
      this.anisotropy = source.anisotropy;
      this.format = source.format;
      this.internalFormat = source.internalFormat;
      this.type = source.type;
      this.offset.copy(source.offset);
      this.repeat.copy(source.repeat);
      this.center.copy(source.center);
      this.rotation = source.rotation;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrix.copy(source.matrix);
      this.generateMipmaps = source.generateMipmaps;
      this.premultiplyAlpha = source.premultiplyAlpha;
      this.flipY = source.flipY;
      this.unpackAlignment = source.unpackAlignment;
      this.colorSpace = source.colorSpace;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      this.needsUpdate = true;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var isRootObject = meta === undefined || typeof meta === 'string';
      if (!isRootObject && meta.textures[this.uuid] !== undefined) {
        return meta.textures[this.uuid];
      }
      var output = {
        metadata: {
          version: 4.6,
          type: 'Texture',
          generator: 'Texture.toJSON'
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(meta).uuid,
        mapping: this.mapping,
        channel: this.channel,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        internalFormat: this.internalFormat,
        type: this.type,
        colorSpace: this.colorSpace,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        generateMipmaps: this.generateMipmaps,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      if (Object.keys(this.userData).length > 0) output.userData = this.userData;
      if (!isRootObject) {
        meta.textures[this.uuid] = output;
      }
      return output;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
    }
  }, {
    key: "transformUv",
    value: function transformUv(uv) {
      if (this.mapping !== UVMapping) return uv;
      uv.applyMatrix3(this.matrix);
      if (uv.x < 0 || uv.x > 1) {
        switch (this.wrapS) {
          case RepeatWrapping:
            uv.x = uv.x - Math.floor(uv.x);
            break;
          case ClampToEdgeWrapping:
            uv.x = uv.x < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.x) % 2) === 1) {
              uv.x = Math.ceil(uv.x) - uv.x;
            } else {
              uv.x = uv.x - Math.floor(uv.x);
            }
            break;
        }
      }
      if (uv.y < 0 || uv.y > 1) {
        switch (this.wrapT) {
          case RepeatWrapping:
            uv.y = uv.y - Math.floor(uv.y);
            break;
          case ClampToEdgeWrapping:
            uv.y = uv.y < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.y) % 2) === 1) {
              uv.y = Math.ceil(uv.y) - uv.y;
            } else {
              uv.y = uv.y - Math.floor(uv.y);
            }
            break;
        }
      }
      if (this.flipY) {
        uv.y = 1 - uv.y;
      }
      return uv;
    }
  }, {
    key: "needsUpdate",
    set: function set(value) {
      if (value === true) {
        this.version++;
        this.source.needsUpdate = true;
      }
    }
  }, {
    key: "encoding",
    get: function get() {
      // @deprecated, r152

      warnOnce('THREE.Texture: Property .encoding has been replaced by .colorSpace.');
      return this.colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;
    },
    set: function set(encoding) {
      // @deprecated, r152

      warnOnce('THREE.Texture: Property .encoding has been replaced by .colorSpace.');
      this.colorSpace = encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
    }
  }]);
  return Texture;
}(EventDispatcher);
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
var Vector4 = /*#__PURE__*/function (_Symbol$iterator2) {
  function Vector4() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    _classCallCheck(this, Vector4);
    Vector4.prototype.isVector4 = true;
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  _createClass(Vector4, [{
    key: "width",
    get: function get() {
      return this.z;
    },
    set: function set(value) {
      this.z = value;
    }
  }, {
    key: "height",
    get: function get() {
      return this.w;
    },
    set: function set(value) {
      this.w = value;
    }
  }, {
    key: "set",
    value: function set(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      this.w = scalar;
      return this;
    }
  }, {
    key: "setX",
    value: function setX(x) {
      this.x = x;
      return this;
    }
  }, {
    key: "setY",
    value: function setY(y) {
      this.y = y;
      return this;
    }
  }, {
    key: "setZ",
    value: function setZ(z) {
      this.z = z;
      return this;
    }
  }, {
    key: "setW",
    value: function setW(w) {
      this.w = w;
      return this;
    }
  }, {
    key: "setComponent",
    value: function setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        case 3:
          this.w = value;
          break;
        default:
          throw new Error('index is out of range: ' + index);
      }
      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error('index is out of range: ' + index);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
  }, {
    key: "copy",
    value: function copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      this.w = v.w !== undefined ? v.w : 1;
      return this;
    }
  }, {
    key: "add",
    value: function add(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      this.w += v.w;
      return this;
    }
  }, {
    key: "addScalar",
    value: function addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      this.w += s;
      return this;
    }
  }, {
    key: "addVectors",
    value: function addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      this.w = a.w + b.w;
      return this;
    }
  }, {
    key: "addScaledVector",
    value: function addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      this.w += v.w * s;
      return this;
    }
  }, {
    key: "sub",
    value: function sub(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      this.w -= v.w;
      return this;
    }
  }, {
    key: "subScalar",
    value: function subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      this.w -= s;
      return this;
    }
  }, {
    key: "subVectors",
    value: function subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      this.w = a.w - b.w;
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      this.w *= v.w;
      return this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      this.w *= scalar;
      return this;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(m) {
      var x = this.x,
        y = this.y,
        z = this.z,
        w = this.w;
      var e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
      this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
      this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
      this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
      return this;
    }
  }, {
    key: "divideScalar",
    value: function divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
  }, {
    key: "setAxisAngleFromQuaternion",
    value: function setAxisAngleFromQuaternion(q) {
      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

      // q is assumed to be normalized

      this.w = 2 * Math.acos(q.w);
      var s = Math.sqrt(1 - q.w * q.w);
      if (s < 0.0001) {
        this.x = 1;
        this.y = 0;
        this.z = 0;
      } else {
        this.x = q.x / s;
        this.y = q.y / s;
        this.z = q.z / s;
      }
      return this;
    }
  }, {
    key: "setAxisAngleFromRotationMatrix",
    value: function setAxisAngleFromRotationMatrix(m) {
      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

      var angle, x, y, z; // variables for result
      var epsilon = 0.01,
        // margin to allow for rounding errors
        epsilon2 = 0.1,
        // margin to distinguish between 0 and 180 degrees

        te = m.elements,
        m11 = te[0],
        m12 = te[4],
        m13 = te[8],
        m21 = te[1],
        m22 = te[5],
        m23 = te[9],
        m31 = te[2],
        m32 = te[6],
        m33 = te[10];
      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
        // singularity found
        // first check for identity matrix which must have +1 for all terms
        // in leading diagonal and zero in other terms

        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
          // this singularity is identity matrix so angle = 0

          this.set(1, 0, 0, 0);
          return this; // zero angle, arbitrary axis
        }

        // otherwise this singularity is angle = 180

        angle = Math.PI;
        var xx = (m11 + 1) / 2;
        var yy = (m22 + 1) / 2;
        var zz = (m33 + 1) / 2;
        var xy = (m12 + m21) / 4;
        var xz = (m13 + m31) / 4;
        var yz = (m23 + m32) / 4;
        if (xx > yy && xx > zz) {
          // m11 is the largest diagonal term

          if (xx < epsilon) {
            x = 0;
            y = 0.707106781;
            z = 0.707106781;
          } else {
            x = Math.sqrt(xx);
            y = xy / x;
            z = xz / x;
          }
        } else if (yy > zz) {
          // m22 is the largest diagonal term

          if (yy < epsilon) {
            x = 0.707106781;
            y = 0;
            z = 0.707106781;
          } else {
            y = Math.sqrt(yy);
            x = xy / y;
            z = yz / y;
          }
        } else {
          // m33 is the largest diagonal term so base result on this

          if (zz < epsilon) {
            x = 0.707106781;
            y = 0.707106781;
            z = 0;
          } else {
            z = Math.sqrt(zz);
            x = xz / z;
            y = yz / z;
          }
        }
        this.set(x, y, z, angle);
        return this; // return 180 deg rotation
      }

      // as we have reached here there are no singularities so we can handle normally

      var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

      if (Math.abs(s) < 0.001) s = 1;

      // prevent divide by zero, should not happen if matrix is orthogonal and should be
      // caught by singularity test above, but I've left it in just in case

      this.x = (m32 - m23) / s;
      this.y = (m13 - m31) / s;
      this.z = (m21 - m12) / s;
      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
      return this;
    }
  }, {
    key: "min",
    value: function min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      this.w = Math.min(this.w, v.w);
      return this;
    }
  }, {
    key: "max",
    value: function max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      this.w = Math.max(this.w, v.w);
      return this;
    }
  }, {
    key: "clamp",
    value: function clamp(min, max) {
      // assumes min < max, componentwise

      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      this.w = Math.max(min.w, Math.min(max.w, this.w));
      return this;
    }
  }, {
    key: "clampScalar",
    value: function clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      this.w = Math.max(minVal, Math.min(maxVal, this.w));
      return this;
    }
  }, {
    key: "clampLength",
    value: function clampLength(min, max) {
      var length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
  }, {
    key: "floor",
    value: function floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      this.w = Math.floor(this.w);
      return this;
    }
  }, {
    key: "ceil",
    value: function ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      this.w = Math.ceil(this.w);
      return this;
    }
  }, {
    key: "round",
    value: function round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      this.w = Math.round(this.w);
      return this;
    }
  }, {
    key: "roundToZero",
    value: function roundToZero() {
      this.x = Math.trunc(this.x);
      this.y = Math.trunc(this.y);
      this.z = Math.trunc(this.z);
      this.w = Math.trunc(this.w);
      return this;
    }
  }, {
    key: "negate",
    value: function negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      this.w = -this.w;
      return this;
    }
  }, {
    key: "dot",
    value: function dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
  }, {
    key: "manhattanLength",
    value: function manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      return this.divideScalar(this.length() || 1);
    }
  }, {
    key: "setLength",
    value: function setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
  }, {
    key: "lerp",
    value: function lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      this.w += (v.w - this.w) * alpha;
      return this;
    }
  }, {
    key: "lerpVectors",
    value: function lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      this.w = v1.w + (v2.w - v1.w) * alpha;
      return this;
    }
  }, {
    key: "equals",
    value: function equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      this.w = array[offset + 3];
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      array[offset + 3] = this.w;
      return array;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(attribute, index) {
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      this.w = attribute.getW(index);
      return this;
    }
  }, {
    key: "random",
    value: function random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      this.w = Math.random();
      return this;
    }
  }, {
    key: _Symbol$iterator2,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      return _regeneratorRuntime().wrap(function value$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.x;
          case 2:
            _context2.next = 4;
            return this.y;
          case 4:
            _context2.next = 6;
            return this.z;
          case 6:
            _context2.next = 8;
            return this.w;
          case 8:
          case "end":
            return _context2.stop();
        }
      }, value, this);
    })
  }]);
  return Vector4;
}(Symbol.iterator);
var Quaternion = /*#__PURE__*/function (_Symbol$iterator3) {
  function Quaternion() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    _classCallCheck(this, Quaternion);
    this.isQuaternion = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  _createClass(Quaternion, [{
    key: "x",
    get: function get() {
      return this._x;
    },
    set: function set(value) {
      this._x = value;
      this._onChangeCallback();
    }
  }, {
    key: "y",
    get: function get() {
      return this._y;
    },
    set: function set(value) {
      this._y = value;
      this._onChangeCallback();
    }
  }, {
    key: "z",
    get: function get() {
      return this._z;
    },
    set: function set(value) {
      this._z = value;
      this._onChangeCallback();
    }
  }, {
    key: "w",
    get: function get() {
      return this._w;
    },
    set: function set(value) {
      this._w = value;
      this._onChangeCallback();
    }
  }, {
    key: "set",
    value: function set(x, y, z, w) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
  }, {
    key: "copy",
    value: function copy(quaternion) {
      this._x = quaternion.x;
      this._y = quaternion.y;
      this._z = quaternion.z;
      this._w = quaternion.w;
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "setFromEuler",
    value: function setFromEuler(euler) {
      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var x = euler._x,
        y = euler._y,
        z = euler._z,
        order = euler._order;

      // http://www.mathworks.com/matlabcentral/fileexchange/
      // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
      //	content/SpinCalc.m

      var cos = Math.cos;
      var sin = Math.sin;
      var c1 = cos(x / 2);
      var c2 = cos(y / 2);
      var c3 = cos(z / 2);
      var s1 = sin(x / 2);
      var s2 = sin(y / 2);
      var s3 = sin(z / 2);
      switch (order) {
        case 'XYZ':
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case 'YXZ':
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case 'ZXY':
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case 'ZYX':
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case 'YZX':
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case 'XZY':
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        default:
          console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
      }
      if (update === true) this._onChangeCallback();
      return this;
    }
  }, {
    key: "setFromAxisAngle",
    value: function setFromAxisAngle(axis, angle) {
      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

      // assumes axis is normalized

      var halfAngle = angle / 2,
        s = Math.sin(halfAngle);
      this._x = axis.x * s;
      this._y = axis.y * s;
      this._z = axis.z * s;
      this._w = Math.cos(halfAngle);
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "setFromRotationMatrix",
    value: function setFromRotationMatrix(m) {
      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

      var te = m.elements,
        m11 = te[0],
        m12 = te[4],
        m13 = te[8],
        m21 = te[1],
        m22 = te[5],
        m23 = te[9],
        m31 = te[2],
        m32 = te[6],
        m33 = te[10],
        trace = m11 + m22 + m33;
      if (trace > 0) {
        var s = 0.5 / Math.sqrt(trace + 1.0);
        this._w = 0.25 / s;
        this._x = (m32 - m23) * s;
        this._y = (m13 - m31) * s;
        this._z = (m21 - m12) * s;
      } else if (m11 > m22 && m11 > m33) {
        var _s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
        this._w = (m32 - m23) / _s;
        this._x = 0.25 * _s;
        this._y = (m12 + m21) / _s;
        this._z = (m13 + m31) / _s;
      } else if (m22 > m33) {
        var _s2 = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
        this._w = (m13 - m31) / _s2;
        this._x = (m12 + m21) / _s2;
        this._y = 0.25 * _s2;
        this._z = (m23 + m32) / _s2;
      } else {
        var _s3 = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
        this._w = (m21 - m12) / _s3;
        this._x = (m13 + m31) / _s3;
        this._y = (m23 + m32) / _s3;
        this._z = 0.25 * _s3;
      }
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "setFromUnitVectors",
    value: function setFromUnitVectors(vFrom, vTo) {
      // assumes direction vectors vFrom and vTo are normalized

      var r = vFrom.dot(vTo) + 1;
      if (r < Number.EPSILON) {
        // vFrom and vTo point in opposite directions

        r = 0;
        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          this._x = -vFrom.y;
          this._y = vFrom.x;
          this._z = 0;
          this._w = r;
        } else {
          this._x = 0;
          this._y = -vFrom.z;
          this._z = vFrom.y;
          this._w = r;
        }
      } else {
        // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
        this._w = r;
      }
      return this.normalize();
    }
  }, {
    key: "angleTo",
    value: function angleTo(q) {
      return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
    }
  }, {
    key: "rotateTowards",
    value: function rotateTowards(q, step) {
      var angle = this.angleTo(q);
      if (angle === 0) return this;
      var t = Math.min(1, step / angle);
      this.slerp(q, t);
      return this;
    }
  }, {
    key: "identity",
    value: function identity() {
      return this.set(0, 0, 0, 1);
    }
  }, {
    key: "invert",
    value: function invert() {
      // quaternion is assumed to have unit length

      return this.conjugate();
    }
  }, {
    key: "conjugate",
    value: function conjugate() {
      this._x *= -1;
      this._y *= -1;
      this._z *= -1;
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "dot",
    value: function dot(v) {
      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      var l = this.length();
      if (l === 0) {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
      } else {
        l = 1 / l;
        this._x = this._x * l;
        this._y = this._y * l;
        this._z = this._z * l;
        this._w = this._w * l;
      }
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(q) {
      return this.multiplyQuaternions(this, q);
    }
  }, {
    key: "premultiply",
    value: function premultiply(q) {
      return this.multiplyQuaternions(q, this);
    }
  }, {
    key: "multiplyQuaternions",
    value: function multiplyQuaternions(a, b) {
      // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

      var qax = a._x,
        qay = a._y,
        qaz = a._z,
        qaw = a._w;
      var qbx = b._x,
        qby = b._y,
        qbz = b._z,
        qbw = b._w;
      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "slerp",
    value: function slerp(qb, t) {
      if (t === 0) return this;
      if (t === 1) return this.copy(qb);
      var x = this._x,
        y = this._y,
        z = this._z,
        w = this._w;

      // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

      var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
      if (cosHalfTheta < 0) {
        this._w = -qb._w;
        this._x = -qb._x;
        this._y = -qb._y;
        this._z = -qb._z;
        cosHalfTheta = -cosHalfTheta;
      } else {
        this.copy(qb);
      }
      if (cosHalfTheta >= 1.0) {
        this._w = w;
        this._x = x;
        this._y = y;
        this._z = z;
        return this;
      }
      var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
      if (sqrSinHalfTheta <= Number.EPSILON) {
        var s = 1 - t;
        this._w = s * w + t * this._w;
        this._x = s * x + t * this._x;
        this._y = s * y + t * this._y;
        this._z = s * z + t * this._z;
        this.normalize(); // normalize calls _onChangeCallback()

        return this;
      }
      var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
      var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
      var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
        ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
      this._w = w * ratioA + this._w * ratioB;
      this._x = x * ratioA + this._x * ratioB;
      this._y = y * ratioA + this._y * ratioB;
      this._z = z * ratioA + this._z * ratioB;
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "slerpQuaternions",
    value: function slerpQuaternions(qa, qb, t) {
      return this.copy(qa).slerp(qb, t);
    }
  }, {
    key: "random",
    value: function random() {
      // Derived from http://planning.cs.uiuc.edu/node198.html
      // Note, this source uses w, x, y, z ordering,
      // so we swap the order below.

      var u1 = Math.random();
      var sqrt1u1 = Math.sqrt(1 - u1);
      var sqrtu1 = Math.sqrt(u1);
      var u2 = 2 * Math.PI * Math.random();
      var u3 = 2 * Math.PI * Math.random();
      return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
    }
  }, {
    key: "equals",
    value: function equals(quaternion) {
      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this._w = array[offset + 3];
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._w;
      return array;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(attribute, index) {
      this._x = attribute.getX(index);
      this._y = attribute.getY(index);
      this._z = attribute.getZ(index);
      this._w = attribute.getW(index);
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toArray();
    }
  }, {
    key: "_onChange",
    value: function _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
  }, {
    key: "_onChangeCallback",
    value: function _onChangeCallback() {}
  }, {
    key: _Symbol$iterator3,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      return _regeneratorRuntime().wrap(function value$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return this._x;
          case 2:
            _context3.next = 4;
            return this._y;
          case 4:
            _context3.next = 6;
            return this._z;
          case 6:
            _context3.next = 8;
            return this._w;
          case 8:
          case "end":
            return _context3.stop();
        }
      }, value, this);
    })
  }], [{
    key: "slerpFlat",
    value: function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
      // fuzz-free, array-based Quaternion SLERP operation

      var x0 = src0[srcOffset0 + 0],
        y0 = src0[srcOffset0 + 1],
        z0 = src0[srcOffset0 + 2],
        w0 = src0[srcOffset0 + 3];
      var x1 = src1[srcOffset1 + 0],
        y1 = src1[srcOffset1 + 1],
        z1 = src1[srcOffset1 + 2],
        w1 = src1[srcOffset1 + 3];
      if (t === 0) {
        dst[dstOffset + 0] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
        return;
      }
      if (t === 1) {
        dst[dstOffset + 0] = x1;
        dst[dstOffset + 1] = y1;
        dst[dstOffset + 2] = z1;
        dst[dstOffset + 3] = w1;
        return;
      }
      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
        var s = 1 - t;
        var cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
          dir = cos >= 0 ? 1 : -1,
          sqrSin = 1 - cos * cos;

        // Skip the Slerp for tiny steps to avoid numeric problems:
        if (sqrSin > Number.EPSILON) {
          var sin = Math.sqrt(sqrSin),
            len = Math.atan2(sin, cos * dir);
          s = Math.sin(s * len) / sin;
          t = Math.sin(t * len) / sin;
        }
        var tDir = t * dir;
        x0 = x0 * s + x1 * tDir;
        y0 = y0 * s + y1 * tDir;
        z0 = z0 * s + z1 * tDir;
        w0 = w0 * s + w1 * tDir;

        // Normalize in case we just did a lerp:
        if (s === 1 - t) {
          var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
          x0 *= f;
          y0 *= f;
          z0 *= f;
          w0 *= f;
        }
      }
      dst[dstOffset] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
    }
  }, {
    key: "multiplyQuaternionsFlat",
    value: function multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
      var x0 = src0[srcOffset0];
      var y0 = src0[srcOffset0 + 1];
      var z0 = src0[srcOffset0 + 2];
      var w0 = src0[srcOffset0 + 3];
      var x1 = src1[srcOffset1];
      var y1 = src1[srcOffset1 + 1];
      var z1 = src1[srcOffset1 + 2];
      var w1 = src1[srcOffset1 + 3];
      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
      return dst;
    }
  }]);
  return Quaternion;
}(Symbol.iterator);
var Vector3 = /*#__PURE__*/function (_Symbol$iterator4) {
  function Vector3() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    _classCallCheck(this, Vector3);
    Vector3.prototype.isVector3 = true;
    this.x = x;
    this.y = y;
    this.z = z;
  }
  _createClass(Vector3, [{
    key: "set",
    value: function set(x, y, z) {
      if (z === undefined) z = this.z; // sprite.scale.set(x,y)

      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      return this;
    }
  }, {
    key: "setX",
    value: function setX(x) {
      this.x = x;
      return this;
    }
  }, {
    key: "setY",
    value: function setY(y) {
      this.y = y;
      return this;
    }
  }, {
    key: "setZ",
    value: function setZ(z) {
      this.z = z;
      return this;
    }
  }, {
    key: "setComponent",
    value: function setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        default:
          throw new Error('index is out of range: ' + index);
      }
      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error('index is out of range: ' + index);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
  }, {
    key: "copy",
    value: function copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      return this;
    }
  }, {
    key: "add",
    value: function add(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    }
  }, {
    key: "addScalar",
    value: function addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      return this;
    }
  }, {
    key: "addVectors",
    value: function addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      return this;
    }
  }, {
    key: "addScaledVector",
    value: function addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      return this;
    }
  }, {
    key: "sub",
    value: function sub(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    }
  }, {
    key: "subScalar",
    value: function subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      return this;
    }
  }, {
    key: "subVectors",
    value: function subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      return this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      return this;
    }
  }, {
    key: "multiplyVectors",
    value: function multiplyVectors(a, b) {
      this.x = a.x * b.x;
      this.y = a.y * b.y;
      this.z = a.z * b.z;
      return this;
    }
  }, {
    key: "applyEuler",
    value: function applyEuler(euler) {
      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
    }
  }, {
    key: "applyAxisAngle",
    value: function applyAxisAngle(axis, angle) {
      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
    }
  }, {
    key: "applyMatrix3",
    value: function applyMatrix3(m) {
      var x = this.x,
        y = this.y,
        z = this.z;
      var e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6] * z;
      this.y = e[1] * x + e[4] * y + e[7] * z;
      this.z = e[2] * x + e[5] * y + e[8] * z;
      return this;
    }
  }, {
    key: "applyNormalMatrix",
    value: function applyNormalMatrix(m) {
      return this.applyMatrix3(m).normalize();
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(m) {
      var x = this.x,
        y = this.y,
        z = this.z;
      var e = m.elements;
      var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
      this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
      this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
      return this;
    }
  }, {
    key: "applyQuaternion",
    value: function applyQuaternion(q) {
      // quaternion q is assumed to have unit length

      var vx = this.x,
        vy = this.y,
        vz = this.z;
      var qx = q.x,
        qy = q.y,
        qz = q.z,
        qw = q.w;

      // t = 2 * cross( q.xyz, v );
      var tx = 2 * (qy * vz - qz * vy);
      var ty = 2 * (qz * vx - qx * vz);
      var tz = 2 * (qx * vy - qy * vx);

      // v + q.w * t + cross( q.xyz, t );
      this.x = vx + qw * tx + qy * tz - qz * ty;
      this.y = vy + qw * ty + qz * tx - qx * tz;
      this.z = vz + qw * tz + qx * ty - qy * tx;
      return this;
    }
  }, {
    key: "project",
    value: function project(camera) {
      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    }
  }, {
    key: "unproject",
    value: function unproject(camera) {
      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(m) {
      // input: THREE.Matrix4 affine matrix
      // vector interpreted as a direction

      var x = this.x,
        y = this.y,
        z = this.z;
      var e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z;
      this.y = e[1] * x + e[5] * y + e[9] * z;
      this.z = e[2] * x + e[6] * y + e[10] * z;
      return this.normalize();
    }
  }, {
    key: "divide",
    value: function divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
      return this;
    }
  }, {
    key: "divideScalar",
    value: function divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
  }, {
    key: "min",
    value: function min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      return this;
    }
  }, {
    key: "max",
    value: function max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      return this;
    }
  }, {
    key: "clamp",
    value: function clamp(min, max) {
      // assumes min < max, componentwise

      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      return this;
    }
  }, {
    key: "clampScalar",
    value: function clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      return this;
    }
  }, {
    key: "clampLength",
    value: function clampLength(min, max) {
      var length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
  }, {
    key: "floor",
    value: function floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      return this;
    }
  }, {
    key: "ceil",
    value: function ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      return this;
    }
  }, {
    key: "round",
    value: function round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      return this;
    }
  }, {
    key: "roundToZero",
    value: function roundToZero() {
      this.x = Math.trunc(this.x);
      this.y = Math.trunc(this.y);
      this.z = Math.trunc(this.z);
      return this;
    }
  }, {
    key: "negate",
    value: function negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    }
  }, {
    key: "dot",
    value: function dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    }

    // TODO lengthSquared?
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
  }, {
    key: "manhattanLength",
    value: function manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      return this.divideScalar(this.length() || 1);
    }
  }, {
    key: "setLength",
    value: function setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
  }, {
    key: "lerp",
    value: function lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      return this;
    }
  }, {
    key: "lerpVectors",
    value: function lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      return this;
    }
  }, {
    key: "cross",
    value: function cross(v) {
      return this.crossVectors(this, v);
    }
  }, {
    key: "crossVectors",
    value: function crossVectors(a, b) {
      var ax = a.x,
        ay = a.y,
        az = a.z;
      var bx = b.x,
        by = b.y,
        bz = b.z;
      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;
      return this;
    }
  }, {
    key: "projectOnVector",
    value: function projectOnVector(v) {
      var denominator = v.lengthSq();
      if (denominator === 0) return this.set(0, 0, 0);
      var scalar = v.dot(this) / denominator;
      return this.copy(v).multiplyScalar(scalar);
    }
  }, {
    key: "projectOnPlane",
    value: function projectOnPlane(planeNormal) {
      _vector$c.copy(this).projectOnVector(planeNormal);
      return this.sub(_vector$c);
    }
  }, {
    key: "reflect",
    value: function reflect(normal) {
      // reflect incident vector off plane orthogonal to normal
      // normal is assumed to have unit length

      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
  }, {
    key: "angleTo",
    value: function angleTo(v) {
      var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
      if (denominator === 0) return Math.PI / 2;
      var theta = this.dot(v) / denominator;

      // clamp, to handle numerical problems

      return Math.acos(clamp(theta, -1, 1));
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
  }, {
    key: "distanceToSquared",
    value: function distanceToSquared(v) {
      var dx = this.x - v.x,
        dy = this.y - v.y,
        dz = this.z - v.z;
      return dx * dx + dy * dy + dz * dz;
    }
  }, {
    key: "manhattanDistanceTo",
    value: function manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    }
  }, {
    key: "setFromSpherical",
    value: function setFromSpherical(s) {
      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }
  }, {
    key: "setFromSphericalCoords",
    value: function setFromSphericalCoords(radius, phi, theta) {
      var sinPhiRadius = Math.sin(phi) * radius;
      this.x = sinPhiRadius * Math.sin(theta);
      this.y = Math.cos(phi) * radius;
      this.z = sinPhiRadius * Math.cos(theta);
      return this;
    }
  }, {
    key: "setFromCylindrical",
    value: function setFromCylindrical(c) {
      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    }
  }, {
    key: "setFromCylindricalCoords",
    value: function setFromCylindricalCoords(radius, theta, y) {
      this.x = radius * Math.sin(theta);
      this.y = y;
      this.z = radius * Math.cos(theta);
      return this;
    }
  }, {
    key: "setFromMatrixPosition",
    value: function setFromMatrixPosition(m) {
      var e = m.elements;
      this.x = e[12];
      this.y = e[13];
      this.z = e[14];
      return this;
    }
  }, {
    key: "setFromMatrixScale",
    value: function setFromMatrixScale(m) {
      var sx = this.setFromMatrixColumn(m, 0).length();
      var sy = this.setFromMatrixColumn(m, 1).length();
      var sz = this.setFromMatrixColumn(m, 2).length();
      this.x = sx;
      this.y = sy;
      this.z = sz;
      return this;
    }
  }, {
    key: "setFromMatrixColumn",
    value: function setFromMatrixColumn(m, index) {
      return this.fromArray(m.elements, index * 4);
    }
  }, {
    key: "setFromMatrix3Column",
    value: function setFromMatrix3Column(m, index) {
      return this.fromArray(m.elements, index * 3);
    }
  }, {
    key: "setFromEuler",
    value: function setFromEuler(e) {
      this.x = e._x;
      this.y = e._y;
      this.z = e._z;
      return this;
    }
  }, {
    key: "setFromColor",
    value: function setFromColor(c) {
      this.x = c.r;
      this.y = c.g;
      this.z = c.b;
      return this;
    }
  }, {
    key: "equals",
    value: function equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      return array;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(attribute, index) {
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      return this;
    }
  }, {
    key: "random",
    value: function random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      return this;
    }
  }, {
    key: "randomDirection",
    value: function randomDirection() {
      // Derived from https://mathworld.wolfram.com/SpherePointPicking.html

      var u = (Math.random() - 0.5) * 2;
      var t = Math.random() * Math.PI * 2;
      var f = Math.sqrt(1 - Math.pow(u, 2));
      this.x = f * Math.cos(t);
      this.y = f * Math.sin(t);
      this.z = u;
      return this;
    }
  }, {
    key: _Symbol$iterator4,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      return _regeneratorRuntime().wrap(function value$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return this.x;
          case 2:
            _context4.next = 4;
            return this.y;
          case 4:
            _context4.next = 6;
            return this.z;
          case 6:
          case "end":
            return _context4.stop();
        }
      }, value, this);
    })
  }]);
  return Vector3;
}(Symbol.iterator);
var _vector$c = /*@__PURE__*/new Vector3();
var _quaternion$4 = /*@__PURE__*/new Quaternion();
var Box3 = /*#__PURE__*/function () {
  function Box3() {
    var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(+Infinity, +Infinity, +Infinity);
    var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3(-Infinity, -Infinity, -Infinity);
    _classCallCheck(this, Box3);
    this.isBox3 = true;
    this.min = min;
    this.max = max;
  }
  _createClass(Box3, [{
    key: "set",
    value: function set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    }
  }, {
    key: "setFromArray",
    value: function setFromArray(array) {
      this.makeEmpty();
      for (var i = 0, il = array.length; i < il; i += 3) {
        this.expandByPoint(_vector$b.fromArray(array, i));
      }
      return this;
    }
  }, {
    key: "setFromBufferAttribute",
    value: function setFromBufferAttribute(attribute) {
      this.makeEmpty();
      for (var i = 0, il = attribute.count; i < il; i++) {
        this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i));
      }
      return this;
    }
  }, {
    key: "setFromPoints",
    value: function setFromPoints(points) {
      this.makeEmpty();
      for (var i = 0, il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }
      return this;
    }
  }, {
    key: "setFromCenterAndSize",
    value: function setFromCenterAndSize(center, size) {
      var halfSize = _vector$b.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
  }, {
    key: "setFromObject",
    value: function setFromObject(object) {
      var precise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.makeEmpty();
      return this.expandByObject(object, precise);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
  }, {
    key: "makeEmpty",
    value: function makeEmpty() {
      this.min.x = this.min.y = this.min.z = +Infinity;
      this.max.x = this.max.y = this.max.z = -Infinity;
      return this;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
  }, {
    key: "getCenter",
    value: function getCenter(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
  }, {
    key: "getSize",
    value: function getSize(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    }
  }, {
    key: "expandByPoint",
    value: function expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
  }, {
    key: "expandByVector",
    value: function expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
  }, {
    key: "expandByScalar",
    value: function expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
  }, {
    key: "expandByObject",
    value: function expandByObject(object) {
      var precise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      // Computes the world-axis-aligned bounding box of an object (including its children),
      // accounting for both the object's, and children's, world transforms

      object.updateWorldMatrix(false, false);
      var geometry = object.geometry;
      if (geometry !== undefined) {
        var positionAttribute = geometry.getAttribute('position');

        // precise AABB computation based on vertex data requires at least a position attribute.
        // instancing isn't supported so far and uses the normal (conservative) code path.

        if (precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true) {
          for (var i = 0, l = positionAttribute.count; i < l; i++) {
            if (object.isMesh === true) {
              object.getVertexPosition(i, _vector$b);
            } else {
              _vector$b.fromBufferAttribute(positionAttribute, i);
            }
            _vector$b.applyMatrix4(object.matrixWorld);
            this.expandByPoint(_vector$b);
          }
        } else {
          if (object.boundingBox !== undefined) {
            // object-level bounding box

            if (object.boundingBox === null) {
              object.computeBoundingBox();
            }
            _box$4.copy(object.boundingBox);
          } else {
            // geometry-level bounding box

            if (geometry.boundingBox === null) {
              geometry.computeBoundingBox();
            }
            _box$4.copy(geometry.boundingBox);
          }
          _box$4.applyMatrix4(object.matrixWorld);
          this.union(_box$4);
        }
      }
      var children = object.children;
      for (var _i2 = 0, _l = children.length; _i2 < _l; _i2++) {
        this.expandByObject(children[_i2], precise);
      }
      return this;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
    }
  }, {
    key: "containsBox",
    value: function containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    }
  }, {
    key: "getParameter",
    value: function getParameter(point, target) {
      // This can potentially have a divide by zero if the box
      // has a size dimension of 0.

      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      // using 6 splitting planes to rule out intersections.
      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(sphere) {
      // Find the point on the AABB closest to the sphere center.
      this.clampPoint(sphere.center, _vector$b);

      // If that point is inside the sphere, the AABB and sphere intersect.
      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
  }, {
    key: "intersectsPlane",
    value: function intersectsPlane(plane) {
      // We compute the minimum and maximum dot product values. If those values
      // are on the same side (back or front) of the plane, then there is no intersection.

      var min, max;
      if (plane.normal.x > 0) {
        min = plane.normal.x * this.min.x;
        max = plane.normal.x * this.max.x;
      } else {
        min = plane.normal.x * this.max.x;
        max = plane.normal.x * this.min.x;
      }
      if (plane.normal.y > 0) {
        min += plane.normal.y * this.min.y;
        max += plane.normal.y * this.max.y;
      } else {
        min += plane.normal.y * this.max.y;
        max += plane.normal.y * this.min.y;
      }
      if (plane.normal.z > 0) {
        min += plane.normal.z * this.min.z;
        max += plane.normal.z * this.max.z;
      } else {
        min += plane.normal.z * this.max.z;
        max += plane.normal.z * this.min.z;
      }
      return min <= -plane.constant && max >= -plane.constant;
    }
  }, {
    key: "intersectsTriangle",
    value: function intersectsTriangle(triangle) {
      if (this.isEmpty()) {
        return false;
      }

      // compute box center and extents
      this.getCenter(_center);
      _extents.subVectors(this.max, _center);

      // translate triangle to aabb origin
      _v0$2.subVectors(triangle.a, _center);
      _v1$7.subVectors(triangle.b, _center);
      _v2$4.subVectors(triangle.c, _center);

      // compute edge vectors for triangle
      _f0.subVectors(_v1$7, _v0$2);
      _f1.subVectors(_v2$4, _v1$7);
      _f2.subVectors(_v0$2, _v2$4);

      // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
      // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
      // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
      var axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
        return false;
      }

      // test 3 face normals from the aabb
      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
        return false;
      }

      // finally testing the face normal of the triangle
      // use already existing triangle edge vectors here
      _triangleNormal.crossVectors(_f0, _f1);
      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
      return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
    }
  }, {
    key: "clampPoint",
    value: function clampPoint(point, target) {
      return target.copy(point).clamp(this.min, this.max);
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point) {
      return this.clampPoint(point, _vector$b).distanceTo(point);
    }
  }, {
    key: "getBoundingSphere",
    value: function getBoundingSphere(target) {
      if (this.isEmpty()) {
        target.makeEmpty();
      } else {
        this.getCenter(target.center);
        target.radius = this.getSize(_vector$b).length() * 0.5;
      }
      return target;
    }
  }, {
    key: "intersect",
    value: function intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);

      // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
      if (this.isEmpty()) this.makeEmpty();
      return this;
    }
  }, {
    key: "union",
    value: function union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix) {
      // transform of empty box is an empty box.
      if (this.isEmpty()) return this;

      // NOTE: I am using a binary pattern to specify all 2^3 combinations below
      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111

      this.setFromPoints(_points);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
  }, {
    key: "equals",
    value: function equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  }]);
  return Box3;
}();
var _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];
var _vector$b = /*@__PURE__*/new Vector3();
var _box$4 = /*@__PURE__*/new Box3();

// triangle centered vertices

var _v0$2 = /*@__PURE__*/new Vector3();
var _v1$7 = /*@__PURE__*/new Vector3();
var _v2$4 = /*@__PURE__*/new Vector3();

// triangle edge vectors

var _f0 = /*@__PURE__*/new Vector3();
var _f1 = /*@__PURE__*/new Vector3();
var _f2 = /*@__PURE__*/new Vector3();
var _center = /*@__PURE__*/new Vector3();
var _extents = /*@__PURE__*/new Vector3();
var _triangleNormal = /*@__PURE__*/new Vector3();
var _testAxis = /*@__PURE__*/new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (var i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i);
    // project the aabb onto the separating axis
    var r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    // project all 3 vertices of the triangle onto the separating axis
    var p0 = v0.dot(_testAxis);
    var p1 = v1.dot(_testAxis);
    var p2 = v2.dot(_testAxis);
    // actual test, basically see if either of the most extreme of the triangle points intersects r
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      // points of the projected triangle are outside the projected half-length of the aabb
      // the axis is separating and we can exit
      return false;
    }
  }
  return true;
}
var _box$3 = /*@__PURE__*/new Box3();
var _v1$6 = /*@__PURE__*/new Vector3();
var _v2$3 = /*@__PURE__*/new Vector3();
var Sphere = /*#__PURE__*/function () {
  function Sphere() {
    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
    var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    _classCallCheck(this, Sphere);
    this.isSphere = true;
    this.center = center;
    this.radius = radius;
  }
  _createClass(Sphere, [{
    key: "set",
    value: function set(center, radius) {
      this.center.copy(center);
      this.radius = radius;
      return this;
    }
  }, {
    key: "setFromPoints",
    value: function setFromPoints(points, optionalCenter) {
      var center = this.center;
      if (optionalCenter !== undefined) {
        center.copy(optionalCenter);
      } else {
        _box$3.setFromPoints(points).getCenter(center);
      }
      var maxRadiusSq = 0;
      for (var i = 0, il = points.length; i < il; i++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
      }
      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(sphere) {
      this.center.copy(sphere.center);
      this.radius = sphere.radius;
      return this;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.radius < 0;
    }
  }, {
    key: "makeEmpty",
    value: function makeEmpty() {
      this.center.set(0, 0, 0);
      this.radius = -1;
      return this;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      return point.distanceToSquared(this.center) <= this.radius * this.radius;
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point) {
      return point.distanceTo(this.center) - this.radius;
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(sphere) {
      var radiusSum = this.radius + sphere.radius;
      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      return box.intersectsSphere(this);
    }
  }, {
    key: "intersectsPlane",
    value: function intersectsPlane(plane) {
      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    }
  }, {
    key: "clampPoint",
    value: function clampPoint(point, target) {
      var deltaLengthSq = this.center.distanceToSquared(point);
      target.copy(point);
      if (deltaLengthSq > this.radius * this.radius) {
        target.sub(this.center).normalize();
        target.multiplyScalar(this.radius).add(this.center);
      }
      return target;
    }
  }, {
    key: "getBoundingBox",
    value: function getBoundingBox(target) {
      if (this.isEmpty()) {
        // Empty sphere produces empty bounding box
        target.makeEmpty();
        return target;
      }
      target.set(this.center, this.center);
      target.expandByScalar(this.radius);
      return target;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix) {
      this.center.applyMatrix4(matrix);
      this.radius = this.radius * matrix.getMaxScaleOnAxis();
      return this;
    }
  }, {
    key: "translate",
    value: function translate(offset) {
      this.center.add(offset);
      return this;
    }
  }, {
    key: "expandByPoint",
    value: function expandByPoint(point) {
      if (this.isEmpty()) {
        this.center.copy(point);
        this.radius = 0;
        return this;
      }
      _v1$6.subVectors(point, this.center);
      var lengthSq = _v1$6.lengthSq();
      if (lengthSq > this.radius * this.radius) {
        // calculate the minimal sphere

        var length = Math.sqrt(lengthSq);
        var delta = (length - this.radius) * 0.5;
        this.center.addScaledVector(_v1$6, delta / length);
        this.radius += delta;
      }
      return this;
    }
  }, {
    key: "union",
    value: function union(sphere) {
      if (sphere.isEmpty()) {
        return this;
      }
      if (this.isEmpty()) {
        this.copy(sphere);
        return this;
      }
      if (this.center.equals(sphere.center) === true) {
        this.radius = Math.max(this.radius, sphere.radius);
      } else {
        _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
        this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
        this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
      }
      return this;
    }
  }, {
    key: "equals",
    value: function equals(sphere) {
      return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
  return Sphere;
}();
var _vector$a = /*@__PURE__*/new Vector3();
var _segCenter = /*@__PURE__*/new Vector3();
var _segDir = /*@__PURE__*/new Vector3();
var _diff = /*@__PURE__*/new Vector3();
var _edge1 = /*@__PURE__*/new Vector3();
var _edge2 = /*@__PURE__*/new Vector3();
var _normal$1 = /*@__PURE__*/new Vector3();
var Ray = /*#__PURE__*/function () {
  function Ray() {
    var origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
    var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3(0, 0, -1);
    _classCallCheck(this, Ray);
    this.origin = origin;
    this.direction = direction;
  }
  _createClass(Ray, [{
    key: "set",
    value: function set(origin, direction) {
      this.origin.copy(origin);
      this.direction.copy(direction);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(ray) {
      this.origin.copy(ray.origin);
      this.direction.copy(ray.direction);
      return this;
    }
  }, {
    key: "at",
    value: function at(t, target) {
      return target.copy(this.origin).addScaledVector(this.direction, t);
    }
  }, {
    key: "lookAt",
    value: function lookAt(v) {
      this.direction.copy(v).sub(this.origin).normalize();
      return this;
    }
  }, {
    key: "recast",
    value: function recast(t) {
      this.origin.copy(this.at(t, _vector$a));
      return this;
    }
  }, {
    key: "closestPointToPoint",
    value: function closestPointToPoint(point, target) {
      target.subVectors(point, this.origin);
      var directionDistance = target.dot(this.direction);
      if (directionDistance < 0) {
        return target.copy(this.origin);
      }
      return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point) {
      return Math.sqrt(this.distanceSqToPoint(point));
    }
  }, {
    key: "distanceSqToPoint",
    value: function distanceSqToPoint(point) {
      var directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);

      // point behind the ray

      if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
      }
      _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);
      return _vector$a.distanceToSquared(point);
    }
  }, {
    key: "distanceSqToSegment",
    value: function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
      // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
      // It returns the min distance between the ray and the segment
      // defined by v0 and v1
      // It can also set two optional targets :
      // - The closest point on the ray
      // - The closest point on the segment

      _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
      _segDir.copy(v1).sub(v0).normalize();
      _diff.copy(this.origin).sub(_segCenter);
      var segExtent = v0.distanceTo(v1) * 0.5;
      var a01 = -this.direction.dot(_segDir);
      var b0 = _diff.dot(this.direction);
      var b1 = -_diff.dot(_segDir);
      var c = _diff.lengthSq();
      var det = Math.abs(1 - a01 * a01);
      var s0, s1, sqrDist, extDet;
      if (det > 0) {
        // The ray and segment are not parallel.

        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;
        if (s0 >= 0) {
          if (s1 >= -extDet) {
            if (s1 <= extDet) {
              // region 0
              // Minimum at interior points of ray and segment.

              var invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
            } else {
              // region 1

              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            // region 5

            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          if (s1 <= -extDet) {
            // region 4

            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          } else if (s1 <= extDet) {
            // region 3

            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c;
          } else {
            // region 2

            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        }
      } else {
        // Ray and segment are parallel.

        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
      }
      if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
      }
      if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
      }
      return sqrDist;
    }
  }, {
    key: "intersectSphere",
    value: function intersectSphere(sphere, target) {
      _vector$a.subVectors(sphere.center, this.origin);
      var tca = _vector$a.dot(this.direction);
      var d2 = _vector$a.dot(_vector$a) - tca * tca;
      var radius2 = sphere.radius * sphere.radius;
      if (d2 > radius2) return null;
      var thc = Math.sqrt(radius2 - d2);

      // t0 = first intersect point - entrance on front of sphere
      var t0 = tca - thc;

      // t1 = second intersect point - exit point on back of sphere
      var t1 = tca + thc;

      // test to see if t1 is behind the ray - if so, return null
      if (t1 < 0) return null;

      // test to see if t0 is behind the ray:
      // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
      // in order to always return an intersect point that is in front of the ray.
      if (t0 < 0) return this.at(t1, target);

      // else t0 is in front of the ray, so return the first collision point scaled by t0
      return this.at(t0, target);
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(sphere) {
      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    }
  }, {
    key: "distanceToPlane",
    value: function distanceToPlane(plane) {
      var denominator = plane.normal.dot(this.direction);
      if (denominator === 0) {
        // line is coplanar, return origin
        if (plane.distanceToPoint(this.origin) === 0) {
          return 0;
        }

        // Null is preferable to undefined since undefined means.... it is undefined

        return null;
      }
      var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;

      // Return if the ray never intersects the plane

      return t >= 0 ? t : null;
    }
  }, {
    key: "intersectPlane",
    value: function intersectPlane(plane, target) {
      var t = this.distanceToPlane(plane);
      if (t === null) {
        return null;
      }
      return this.at(t, target);
    }
  }, {
    key: "intersectsPlane",
    value: function intersectsPlane(plane) {
      // check if the ray lies on the plane first

      var distToPoint = plane.distanceToPoint(this.origin);
      if (distToPoint === 0) {
        return true;
      }
      var denominator = plane.normal.dot(this.direction);
      if (denominator * distToPoint < 0) {
        return true;
      }

      // ray origin is behind the plane (and is pointing behind it)

      return false;
    }
  }, {
    key: "intersectBox",
    value: function intersectBox(box, target) {
      var tmin, tmax, tymin, tymax, tzmin, tzmax;
      var invdirx = 1 / this.direction.x,
        invdiry = 1 / this.direction.y,
        invdirz = 1 / this.direction.z;
      var origin = this.origin;
      if (invdirx >= 0) {
        tmin = (box.min.x - origin.x) * invdirx;
        tmax = (box.max.x - origin.x) * invdirx;
      } else {
        tmin = (box.max.x - origin.x) * invdirx;
        tmax = (box.min.x - origin.x) * invdirx;
      }
      if (invdiry >= 0) {
        tymin = (box.min.y - origin.y) * invdiry;
        tymax = (box.max.y - origin.y) * invdiry;
      } else {
        tymin = (box.max.y - origin.y) * invdiry;
        tymax = (box.min.y - origin.y) * invdiry;
      }
      if (tmin > tymax || tymin > tmax) return null;
      if (tymin > tmin || isNaN(tmin)) tmin = tymin;
      if (tymax < tmax || isNaN(tmax)) tmax = tymax;
      if (invdirz >= 0) {
        tzmin = (box.min.z - origin.z) * invdirz;
        tzmax = (box.max.z - origin.z) * invdirz;
      } else {
        tzmin = (box.max.z - origin.z) * invdirz;
        tzmax = (box.min.z - origin.z) * invdirz;
      }
      if (tmin > tzmax || tzmin > tmax) return null;
      if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
      if (tzmax < tmax || tmax !== tmax) tmax = tzmax;

      //return point closest to the ray (positive side)

      if (tmax < 0) return null;
      return this.at(tmin >= 0 ? tmin : tmax, target);
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      return this.intersectBox(box, _vector$a) !== null;
    }
  }, {
    key: "intersectTriangle",
    value: function intersectTriangle(a, b, c, backfaceCulling, target) {
      // Compute the offset origin, edges, and normal.

      // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

      _edge1.subVectors(b, a);
      _edge2.subVectors(c, a);
      _normal$1.crossVectors(_edge1, _edge2);

      // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
      // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
      //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
      //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
      //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
      var DdN = this.direction.dot(_normal$1);
      var sign;
      if (DdN > 0) {
        if (backfaceCulling) return null;
        sign = 1;
      } else if (DdN < 0) {
        sign = -1;
        DdN = -DdN;
      } else {
        return null;
      }
      _diff.subVectors(this.origin, a);
      var DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));

      // b1 < 0, no intersection
      if (DdQxE2 < 0) {
        return null;
      }
      var DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));

      // b2 < 0, no intersection
      if (DdE1xQ < 0) {
        return null;
      }

      // b1+b2 > 1, no intersection
      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      }

      // Line intersects triangle, check if ray does.
      var QdN = -sign * _diff.dot(_normal$1);

      // t < 0, no intersection
      if (QdN < 0) {
        return null;
      }

      // Ray intersects triangle.
      return this.at(QdN / DdN, target);
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix4) {
      this.origin.applyMatrix4(matrix4);
      this.direction.transformDirection(matrix4);
      return this;
    }
  }, {
    key: "equals",
    value: function equals(ray) {
      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
  return Ray;
}();
var Matrix4 = /*#__PURE__*/function () {
  function Matrix4(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    _classCallCheck(this, Matrix4);
    Matrix4.prototype.isMatrix4 = true;
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    if (n11 !== undefined) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }
  _createClass(Matrix4, [{
    key: "set",
    value: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      var te = this.elements;
      te[0] = n11;
      te[4] = n12;
      te[8] = n13;
      te[12] = n14;
      te[1] = n21;
      te[5] = n22;
      te[9] = n23;
      te[13] = n24;
      te[2] = n31;
      te[6] = n32;
      te[10] = n33;
      te[14] = n34;
      te[3] = n41;
      te[7] = n42;
      te[11] = n43;
      te[15] = n44;
      return this;
    }
  }, {
    key: "identity",
    value: function identity() {
      this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Matrix4().fromArray(this.elements);
    }
  }, {
    key: "copy",
    value: function copy(m) {
      var te = this.elements;
      var me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      te[9] = me[9];
      te[10] = me[10];
      te[11] = me[11];
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      te[15] = me[15];
      return this;
    }
  }, {
    key: "copyPosition",
    value: function copyPosition(m) {
      var te = this.elements,
        me = m.elements;
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      return this;
    }
  }, {
    key: "setFromMatrix3",
    value: function setFromMatrix3(m) {
      var me = m.elements;
      this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "extractBasis",
    value: function extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrixColumn(this, 0);
      yAxis.setFromMatrixColumn(this, 1);
      zAxis.setFromMatrixColumn(this, 2);
      return this;
    }
  }, {
    key: "makeBasis",
    value: function makeBasis(xAxis, yAxis, zAxis) {
      this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "extractRotation",
    value: function extractRotation(m) {
      // this method does not support reflection matrices

      var te = this.elements;
      var me = m.elements;
      var scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
      var scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
      var scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
      te[0] = me[0] * scaleX;
      te[1] = me[1] * scaleX;
      te[2] = me[2] * scaleX;
      te[3] = 0;
      te[4] = me[4] * scaleY;
      te[5] = me[5] * scaleY;
      te[6] = me[6] * scaleY;
      te[7] = 0;
      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
  }, {
    key: "makeRotationFromEuler",
    value: function makeRotationFromEuler(euler) {
      var te = this.elements;
      var x = euler.x,
        y = euler.y,
        z = euler.z;
      var a = Math.cos(x),
        b = Math.sin(x);
      var c = Math.cos(y),
        d = Math.sin(y);
      var e = Math.cos(z),
        f = Math.sin(z);
      if (euler.order === 'XYZ') {
        var ae = a * e,
          af = a * f,
          be = b * e,
          bf = b * f;
        te[0] = c * e;
        te[4] = -c * f;
        te[8] = d;
        te[1] = af + be * d;
        te[5] = ae - bf * d;
        te[9] = -b * c;
        te[2] = bf - ae * d;
        te[6] = be + af * d;
        te[10] = a * c;
      } else if (euler.order === 'YXZ') {
        var ce = c * e,
          cf = c * f,
          de = d * e,
          df = d * f;
        te[0] = ce + df * b;
        te[4] = de * b - cf;
        te[8] = a * d;
        te[1] = a * f;
        te[5] = a * e;
        te[9] = -b;
        te[2] = cf * b - de;
        te[6] = df + ce * b;
        te[10] = a * c;
      } else if (euler.order === 'ZXY') {
        var _ce = c * e,
          _cf = c * f,
          _de = d * e,
          _df = d * f;
        te[0] = _ce - _df * b;
        te[4] = -a * f;
        te[8] = _de + _cf * b;
        te[1] = _cf + _de * b;
        te[5] = a * e;
        te[9] = _df - _ce * b;
        te[2] = -a * d;
        te[6] = b;
        te[10] = a * c;
      } else if (euler.order === 'ZYX') {
        var _ae = a * e,
          _af = a * f,
          _be = b * e,
          _bf = b * f;
        te[0] = c * e;
        te[4] = _be * d - _af;
        te[8] = _ae * d + _bf;
        te[1] = c * f;
        te[5] = _bf * d + _ae;
        te[9] = _af * d - _be;
        te[2] = -d;
        te[6] = b * c;
        te[10] = a * c;
      } else if (euler.order === 'YZX') {
        var ac = a * c,
          ad = a * d,
          bc = b * c,
          bd = b * d;
        te[0] = c * e;
        te[4] = bd - ac * f;
        te[8] = bc * f + ad;
        te[1] = f;
        te[5] = a * e;
        te[9] = -b * e;
        te[2] = -d * e;
        te[6] = ad * f + bc;
        te[10] = ac - bd * f;
      } else if (euler.order === 'XZY') {
        var _ac = a * c,
          _ad = a * d,
          _bc = b * c,
          _bd = b * d;
        te[0] = c * e;
        te[4] = -f;
        te[8] = d * e;
        te[1] = _ac * f + _bd;
        te[5] = a * e;
        te[9] = _ad * f - _bc;
        te[2] = _bc * f - _ad;
        te[6] = b * e;
        te[10] = _bd * f + _ac;
      }

      // bottom row
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;

      // last column
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
  }, {
    key: "makeRotationFromQuaternion",
    value: function makeRotationFromQuaternion(q) {
      return this.compose(_zero, q, _one);
    }
  }, {
    key: "lookAt",
    value: function lookAt(eye, target, up) {
      var te = this.elements;
      _z.subVectors(eye, target);
      if (_z.lengthSq() === 0) {
        // eye and target are in the same position

        _z.z = 1;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
      if (_x.lengthSq() === 0) {
        // up and z are parallel

        if (Math.abs(up.z) === 1) {
          _z.x += 0.0001;
        } else {
          _z.z += 0.0001;
        }
        _z.normalize();
        _x.crossVectors(up, _z);
      }
      _x.normalize();
      _y.crossVectors(_z, _x);
      te[0] = _x.x;
      te[4] = _y.x;
      te[8] = _z.x;
      te[1] = _x.y;
      te[5] = _y.y;
      te[9] = _z.y;
      te[2] = _x.z;
      te[6] = _y.z;
      te[10] = _z.z;
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(m) {
      return this.multiplyMatrices(this, m);
    }
  }, {
    key: "premultiply",
    value: function premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
  }, {
    key: "multiplyMatrices",
    value: function multiplyMatrices(a, b) {
      var ae = a.elements;
      var be = b.elements;
      var te = this.elements;
      var a11 = ae[0],
        a12 = ae[4],
        a13 = ae[8],
        a14 = ae[12];
      var a21 = ae[1],
        a22 = ae[5],
        a23 = ae[9],
        a24 = ae[13];
      var a31 = ae[2],
        a32 = ae[6],
        a33 = ae[10],
        a34 = ae[14];
      var a41 = ae[3],
        a42 = ae[7],
        a43 = ae[11],
        a44 = ae[15];
      var b11 = be[0],
        b12 = be[4],
        b13 = be[8],
        b14 = be[12];
      var b21 = be[1],
        b22 = be[5],
        b23 = be[9],
        b24 = be[13];
      var b31 = be[2],
        b32 = be[6],
        b33 = be[10],
        b34 = be[14];
      var b41 = be[3],
        b42 = be[7],
        b43 = be[11],
        b44 = be[15];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
      return this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(s) {
      var te = this.elements;
      te[0] *= s;
      te[4] *= s;
      te[8] *= s;
      te[12] *= s;
      te[1] *= s;
      te[5] *= s;
      te[9] *= s;
      te[13] *= s;
      te[2] *= s;
      te[6] *= s;
      te[10] *= s;
      te[14] *= s;
      te[3] *= s;
      te[7] *= s;
      te[11] *= s;
      te[15] *= s;
      return this;
    }
  }, {
    key: "determinant",
    value: function determinant() {
      var te = this.elements;
      var n11 = te[0],
        n12 = te[4],
        n13 = te[8],
        n14 = te[12];
      var n21 = te[1],
        n22 = te[5],
        n23 = te[9],
        n24 = te[13];
      var n31 = te[2],
        n32 = te[6],
        n33 = te[10],
        n34 = te[14];
      var n41 = te[3],
        n42 = te[7],
        n43 = te[11],
        n44 = te[15];

      //TODO: make this more efficient
      //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    }
  }, {
    key: "transpose",
    value: function transpose() {
      var te = this.elements;
      var tmp;
      tmp = te[1];
      te[1] = te[4];
      te[4] = tmp;
      tmp = te[2];
      te[2] = te[8];
      te[8] = tmp;
      tmp = te[6];
      te[6] = te[9];
      te[9] = tmp;
      tmp = te[3];
      te[3] = te[12];
      te[12] = tmp;
      tmp = te[7];
      te[7] = te[13];
      te[13] = tmp;
      tmp = te[11];
      te[11] = te[14];
      te[14] = tmp;
      return this;
    }
  }, {
    key: "setPosition",
    value: function setPosition(x, y, z) {
      var te = this.elements;
      if (x.isVector3) {
        te[12] = x.x;
        te[13] = x.y;
        te[14] = x.z;
      } else {
        te[12] = x;
        te[13] = y;
        te[14] = z;
      }
      return this;
    }
  }, {
    key: "invert",
    value: function invert() {
      // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
      var te = this.elements,
        n11 = te[0],
        n21 = te[1],
        n31 = te[2],
        n41 = te[3],
        n12 = te[4],
        n22 = te[5],
        n32 = te[6],
        n42 = te[7],
        n13 = te[8],
        n23 = te[9],
        n33 = te[10],
        n43 = te[11],
        n14 = te[12],
        n24 = te[13],
        n34 = te[14],
        n44 = te[15],
        t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
        t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
        t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
        t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
      var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      var detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
      te[4] = t12 * detInv;
      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
      te[8] = t13 * detInv;
      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
      te[12] = t14 * detInv;
      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
      return this;
    }
  }, {
    key: "scale",
    value: function scale(v) {
      var te = this.elements;
      var x = v.x,
        y = v.y,
        z = v.z;
      te[0] *= x;
      te[4] *= y;
      te[8] *= z;
      te[1] *= x;
      te[5] *= y;
      te[9] *= z;
      te[2] *= x;
      te[6] *= y;
      te[10] *= z;
      te[3] *= x;
      te[7] *= y;
      te[11] *= z;
      return this;
    }
  }, {
    key: "getMaxScaleOnAxis",
    value: function getMaxScaleOnAxis() {
      var te = this.elements;
      var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
      var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
      var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
  }, {
    key: "makeTranslation",
    value: function makeTranslation(x, y, z) {
      if (x.isVector3) {
        this.set(1, 0, 0, x.x, 0, 1, 0, x.y, 0, 0, 1, x.z, 0, 0, 0, 1);
      } else {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
      }
      return this;
    }
  }, {
    key: "makeRotationX",
    value: function makeRotationX(theta) {
      var c = Math.cos(theta),
        s = Math.sin(theta);
      this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "makeRotationY",
    value: function makeRotationY(theta) {
      var c = Math.cos(theta),
        s = Math.sin(theta);
      this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "makeRotationZ",
    value: function makeRotationZ(theta) {
      var c = Math.cos(theta),
        s = Math.sin(theta);
      this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "makeRotationAxis",
    value: function makeRotationAxis(axis, angle) {
      // Based on http://www.gamedev.net/reference/articles/article1199.asp

      var c = Math.cos(angle);
      var s = Math.sin(angle);
      var t = 1 - c;
      var x = axis.x,
        y = axis.y,
        z = axis.z;
      var tx = t * x,
        ty = t * y;
      this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "makeScale",
    value: function makeScale(x, y, z) {
      this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "makeShear",
    value: function makeShear(xy, xz, yx, yz, zx, zy) {
      this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "compose",
    value: function compose(position, quaternion, scale) {
      var te = this.elements;
      var x = quaternion._x,
        y = quaternion._y,
        z = quaternion._z,
        w = quaternion._w;
      var x2 = x + x,
        y2 = y + y,
        z2 = z + z;
      var xx = x * x2,
        xy = x * y2,
        xz = x * z2;
      var yy = y * y2,
        yz = y * z2,
        zz = z * z2;
      var wx = w * x2,
        wy = w * y2,
        wz = w * z2;
      var sx = scale.x,
        sy = scale.y,
        sz = scale.z;
      te[0] = (1 - (yy + zz)) * sx;
      te[1] = (xy + wz) * sx;
      te[2] = (xz - wy) * sx;
      te[3] = 0;
      te[4] = (xy - wz) * sy;
      te[5] = (1 - (xx + zz)) * sy;
      te[6] = (yz + wx) * sy;
      te[7] = 0;
      te[8] = (xz + wy) * sz;
      te[9] = (yz - wx) * sz;
      te[10] = (1 - (xx + yy)) * sz;
      te[11] = 0;
      te[12] = position.x;
      te[13] = position.y;
      te[14] = position.z;
      te[15] = 1;
      return this;
    }
  }, {
    key: "decompose",
    value: function decompose(position, quaternion, scale) {
      var te = this.elements;
      var sx = _v1$5.set(te[0], te[1], te[2]).length();
      var sy = _v1$5.set(te[4], te[5], te[6]).length();
      var sz = _v1$5.set(te[8], te[9], te[10]).length();

      // if determine is negative, we need to invert one scale
      var det = this.determinant();
      if (det < 0) sx = -sx;
      position.x = te[12];
      position.y = te[13];
      position.z = te[14];

      // scale the rotation part
      _m1$2.copy(this);
      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;
      _m1$2.elements[0] *= invSX;
      _m1$2.elements[1] *= invSX;
      _m1$2.elements[2] *= invSX;
      _m1$2.elements[4] *= invSY;
      _m1$2.elements[5] *= invSY;
      _m1$2.elements[6] *= invSY;
      _m1$2.elements[8] *= invSZ;
      _m1$2.elements[9] *= invSZ;
      _m1$2.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(_m1$2);
      scale.x = sx;
      scale.y = sy;
      scale.z = sz;
      return this;
    }
  }, {
    key: "makePerspective",
    value: function makePerspective(left, right, top, bottom, near, far) {
      var coordinateSystem = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : WebGLCoordinateSystem;
      var te = this.elements;
      var x = 2 * near / (right - left);
      var y = 2 * near / (top - bottom);
      var a = (right + left) / (right - left);
      var b = (top + bottom) / (top - bottom);
      var c, d;
      if (coordinateSystem === WebGLCoordinateSystem) {
        c = -(far + near) / (far - near);
        d = -2 * far * near / (far - near);
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        c = -far / (far - near);
        d = -far * near / (far - near);
      } else {
        throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem);
      }
      te[0] = x;
      te[4] = 0;
      te[8] = a;
      te[12] = 0;
      te[1] = 0;
      te[5] = y;
      te[9] = b;
      te[13] = 0;
      te[2] = 0;
      te[6] = 0;
      te[10] = c;
      te[14] = d;
      te[3] = 0;
      te[7] = 0;
      te[11] = -1;
      te[15] = 0;
      return this;
    }
  }, {
    key: "makeOrthographic",
    value: function makeOrthographic(left, right, top, bottom, near, far) {
      var coordinateSystem = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : WebGLCoordinateSystem;
      var te = this.elements;
      var w = 1.0 / (right - left);
      var h = 1.0 / (top - bottom);
      var p = 1.0 / (far - near);
      var x = (right + left) * w;
      var y = (top + bottom) * h;
      var z, zInv;
      if (coordinateSystem === WebGLCoordinateSystem) {
        z = (far + near) * p;
        zInv = -2 * p;
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        z = near * p;
        zInv = -1 * p;
      } else {
        throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem);
      }
      te[0] = 2 * w;
      te[4] = 0;
      te[8] = 0;
      te[12] = -x;
      te[1] = 0;
      te[5] = 2 * h;
      te[9] = 0;
      te[13] = -y;
      te[2] = 0;
      te[6] = 0;
      te[10] = zInv;
      te[14] = -z;
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[15] = 1;
      return this;
    }
  }, {
    key: "equals",
    value: function equals(matrix) {
      var te = this.elements;
      var me = matrix.elements;
      for (var i = 0; i < 16; i++) {
        if (te[i] !== me[i]) return false;
      }
      return true;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      for (var i = 0; i < 16; i++) {
        this.elements[i] = array[i + offset];
      }
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      array[offset + 9] = te[9];
      array[offset + 10] = te[10];
      array[offset + 11] = te[11];
      array[offset + 12] = te[12];
      array[offset + 13] = te[13];
      array[offset + 14] = te[14];
      array[offset + 15] = te[15];
      return array;
    }
  }]);
  return Matrix4;
}();
var _v1$5 = /*@__PURE__*/new Vector3();
var _m1$2 = /*@__PURE__*/new Matrix4();
var _zero = /*@__PURE__*/new Vector3(0, 0, 0);
var _one = /*@__PURE__*/new Vector3(1, 1, 1);
var _x = /*@__PURE__*/new Vector3();
var _y = /*@__PURE__*/new Vector3();
var _z = /*@__PURE__*/new Vector3();
var _matrix$1 = /*@__PURE__*/new Matrix4();
var _quaternion$3 = /*@__PURE__*/new Quaternion();
var Euler = /*#__PURE__*/function (_Symbol$iterator5) {
  function Euler() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Euler.DEFAULT_ORDER;
    _classCallCheck(this, Euler);
    this.isEuler = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }
  _createClass(Euler, [{
    key: "x",
    get: function get() {
      return this._x;
    },
    set: function set(value) {
      this._x = value;
      this._onChangeCallback();
    }
  }, {
    key: "y",
    get: function get() {
      return this._y;
    },
    set: function set(value) {
      this._y = value;
      this._onChangeCallback();
    }
  }, {
    key: "z",
    get: function get() {
      return this._z;
    },
    set: function set(value) {
      this._z = value;
      this._onChangeCallback();
    }
  }, {
    key: "order",
    get: function get() {
      return this._order;
    },
    set: function set(value) {
      this._order = value;
      this._onChangeCallback();
    }
  }, {
    key: "set",
    value: function set(x, y, z) {
      var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._order;
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order;
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
  }, {
    key: "copy",
    value: function copy(euler) {
      this._x = euler._x;
      this._y = euler._y;
      this._z = euler._z;
      this._order = euler._order;
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "setFromRotationMatrix",
    value: function setFromRotationMatrix(m) {
      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._order;
      var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

      var te = m.elements;
      var m11 = te[0],
        m12 = te[4],
        m13 = te[8];
      var m21 = te[1],
        m22 = te[5],
        m23 = te[9];
      var m31 = te[2],
        m32 = te[6],
        m33 = te[10];
      switch (order) {
        case 'XYZ':
          this._y = Math.asin(clamp(m13, -1, 1));
          if (Math.abs(m13) < 0.9999999) {
            this._x = Math.atan2(-m23, m33);
            this._z = Math.atan2(-m12, m11);
          } else {
            this._x = Math.atan2(m32, m22);
            this._z = 0;
          }
          break;
        case 'YXZ':
          this._x = Math.asin(-clamp(m23, -1, 1));
          if (Math.abs(m23) < 0.9999999) {
            this._y = Math.atan2(m13, m33);
            this._z = Math.atan2(m21, m22);
          } else {
            this._y = Math.atan2(-m31, m11);
            this._z = 0;
          }
          break;
        case 'ZXY':
          this._x = Math.asin(clamp(m32, -1, 1));
          if (Math.abs(m32) < 0.9999999) {
            this._y = Math.atan2(-m31, m33);
            this._z = Math.atan2(-m12, m22);
          } else {
            this._y = 0;
            this._z = Math.atan2(m21, m11);
          }
          break;
        case 'ZYX':
          this._y = Math.asin(-clamp(m31, -1, 1));
          if (Math.abs(m31) < 0.9999999) {
            this._x = Math.atan2(m32, m33);
            this._z = Math.atan2(m21, m11);
          } else {
            this._x = 0;
            this._z = Math.atan2(-m12, m22);
          }
          break;
        case 'YZX':
          this._z = Math.asin(clamp(m21, -1, 1));
          if (Math.abs(m21) < 0.9999999) {
            this._x = Math.atan2(-m23, m22);
            this._y = Math.atan2(-m31, m11);
          } else {
            this._x = 0;
            this._y = Math.atan2(m13, m33);
          }
          break;
        case 'XZY':
          this._z = Math.asin(-clamp(m12, -1, 1));
          if (Math.abs(m12) < 0.9999999) {
            this._x = Math.atan2(m32, m22);
            this._y = Math.atan2(m13, m11);
          } else {
            this._x = Math.atan2(-m23, m33);
            this._y = 0;
          }
          break;
        default:
          console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
      }
      this._order = order;
      if (update === true) this._onChangeCallback();
      return this;
    }
  }, {
    key: "setFromQuaternion",
    value: function setFromQuaternion(q, order, update) {
      _matrix$1.makeRotationFromQuaternion(q);
      return this.setFromRotationMatrix(_matrix$1, order, update);
    }
  }, {
    key: "setFromVector3",
    value: function setFromVector3(v) {
      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._order;
      return this.set(v.x, v.y, v.z, order);
    }
  }, {
    key: "reorder",
    value: function reorder(newOrder) {
      // WARNING: this discards revolution information -bhouston

      _quaternion$3.setFromEuler(this);
      return this.setFromQuaternion(_quaternion$3, newOrder);
    }
  }, {
    key: "equals",
    value: function equals(euler) {
      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      this._x = array[0];
      this._y = array[1];
      this._z = array[2];
      if (array[3] !== undefined) this._order = array[3];
      this._onChangeCallback();
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._order;
      return array;
    }
  }, {
    key: "_onChange",
    value: function _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
  }, {
    key: "_onChangeCallback",
    value: function _onChangeCallback() {}
  }, {
    key: _Symbol$iterator5,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      return _regeneratorRuntime().wrap(function value$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return this._x;
          case 2:
            _context5.next = 4;
            return this._y;
          case 4:
            _context5.next = 6;
            return this._z;
          case 6:
            _context5.next = 8;
            return this._order;
          case 8:
          case "end":
            return _context5.stop();
        }
      }, value, this);
    })
  }]);
  return Euler;
}(Symbol.iterator);
Euler.DEFAULT_ORDER = 'XYZ';
var Layers = /*#__PURE__*/function () {
  function Layers() {
    _classCallCheck(this, Layers);
    this.mask = 1 | 0;
  }
  _createClass(Layers, [{
    key: "set",
    value: function set(channel) {
      this.mask = (1 << channel | 0) >>> 0;
    }
  }, {
    key: "enable",
    value: function enable(channel) {
      this.mask |= 1 << channel | 0;
    }
  }, {
    key: "enableAll",
    value: function enableAll() {
      this.mask = 0xffffffff | 0;
    }
  }, {
    key: "toggle",
    value: function toggle(channel) {
      this.mask ^= 1 << channel | 0;
    }
  }, {
    key: "disable",
    value: function disable(channel) {
      this.mask &= ~(1 << channel | 0);
    }
  }, {
    key: "disableAll",
    value: function disableAll() {
      this.mask = 0;
    }
  }, {
    key: "test",
    value: function test(layers) {
      return (this.mask & layers.mask) !== 0;
    }
  }, {
    key: "isEnabled",
    value: function isEnabled(channel) {
      return (this.mask & (1 << channel | 0)) !== 0;
    }
  }]);
  return Layers;
}();
var _object3DId = 0;
var _v1$4 = /*@__PURE__*/new Vector3();
var _q1 = /*@__PURE__*/new Quaternion();
var _m1$1 = /*@__PURE__*/new Matrix4();
var _target = /*@__PURE__*/new Vector3();
var _position$3 = /*@__PURE__*/new Vector3();
var _scale$2 = /*@__PURE__*/new Vector3();
var _quaternion$2 = /*@__PURE__*/new Quaternion();
var _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);
var _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);
var _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);
var _addedEvent = {
  type: 'added'
};
var _removedEvent = {
  type: 'removed'
};
var Object3D = /*#__PURE__*/function (_EventDispatcher2) {
  _inherits(Object3D, _EventDispatcher2);
  var _super2 = _createSuper(Object3D);
  function Object3D() {
    var _this2;
    _classCallCheck(this, Object3D);
    _this2 = _super2.call(this);
    _this2.isObject3D = true;
    Object.defineProperty(_assertThisInitialized(_this2), 'id', {
      value: _object3DId++
    });
    _this2.uuid = generateUUID();
    _this2.name = '';
    _this2.type = 'Object3D';
    _this2.parent = null;
    _this2.children = [];
    _this2.up = Object3D.DEFAULT_UP.clone();
    var position = new Vector3();
    var rotation = new Euler();
    var quaternion = new Quaternion();
    var scale = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, undefined, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(_assertThisInitialized(_this2), {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    _this2.matrix = new Matrix4();
    _this2.matrixWorld = new Matrix4();
    _this2.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    _this2.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer
    _this2.matrixWorldNeedsUpdate = false;
    _this2.layers = new Layers();
    _this2.visible = true;
    _this2.castShadow = false;
    _this2.receiveShadow = false;
    _this2.frustumCulled = true;
    _this2.renderOrder = 0;
    _this2.animations = [];
    _this2.userData = {};
    return _this2;
  }
  _createClass(Object3D, [{
    key: "onBeforeShadow",
    value: function onBeforeShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */) {}
  }, {
    key: "onAfterShadow",
    value: function onAfterShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */) {}
  }, {
    key: "onBeforeRender",
    value: function onBeforeRender( /* renderer, scene, camera, geometry, material, group */) {}
  }, {
    key: "onAfterRender",
    value: function onAfterRender( /* renderer, scene, camera, geometry, material, group */) {}
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix) {
      if (this.matrixAutoUpdate) this.updateMatrix();
      this.matrix.premultiply(matrix);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
  }, {
    key: "applyQuaternion",
    value: function applyQuaternion(q) {
      this.quaternion.premultiply(q);
      return this;
    }
  }, {
    key: "setRotationFromAxisAngle",
    value: function setRotationFromAxisAngle(axis, angle) {
      // assumes axis is normalized

      this.quaternion.setFromAxisAngle(axis, angle);
    }
  }, {
    key: "setRotationFromEuler",
    value: function setRotationFromEuler(euler) {
      this.quaternion.setFromEuler(euler, true);
    }
  }, {
    key: "setRotationFromMatrix",
    value: function setRotationFromMatrix(m) {
      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

      this.quaternion.setFromRotationMatrix(m);
    }
  }, {
    key: "setRotationFromQuaternion",
    value: function setRotationFromQuaternion(q) {
      // assumes q is normalized

      this.quaternion.copy(q);
    }
  }, {
    key: "rotateOnAxis",
    value: function rotateOnAxis(axis, angle) {
      // rotate object on axis in object space
      // axis is assumed to be normalized

      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.multiply(_q1);
      return this;
    }
  }, {
    key: "rotateOnWorldAxis",
    value: function rotateOnWorldAxis(axis, angle) {
      // rotate object on axis in world space
      // axis is assumed to be normalized
      // method assumes no rotated parent

      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.premultiply(_q1);
      return this;
    }
  }, {
    key: "rotateX",
    value: function rotateX(angle) {
      return this.rotateOnAxis(_xAxis, angle);
    }
  }, {
    key: "rotateY",
    value: function rotateY(angle) {
      return this.rotateOnAxis(_yAxis, angle);
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(angle) {
      return this.rotateOnAxis(_zAxis, angle);
    }
  }, {
    key: "translateOnAxis",
    value: function translateOnAxis(axis, distance) {
      // translate object by distance along axis in object space
      // axis is assumed to be normalized

      _v1$4.copy(axis).applyQuaternion(this.quaternion);
      this.position.add(_v1$4.multiplyScalar(distance));
      return this;
    }
  }, {
    key: "translateX",
    value: function translateX(distance) {
      return this.translateOnAxis(_xAxis, distance);
    }
  }, {
    key: "translateY",
    value: function translateY(distance) {
      return this.translateOnAxis(_yAxis, distance);
    }
  }, {
    key: "translateZ",
    value: function translateZ(distance) {
      return this.translateOnAxis(_zAxis, distance);
    }
  }, {
    key: "localToWorld",
    value: function localToWorld(vector) {
      this.updateWorldMatrix(true, false);
      return vector.applyMatrix4(this.matrixWorld);
    }
  }, {
    key: "worldToLocal",
    value: function worldToLocal(vector) {
      this.updateWorldMatrix(true, false);
      return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
    }
  }, {
    key: "lookAt",
    value: function lookAt(x, y, z) {
      // This method does not support objects having non-uniformly-scaled parent(s)

      if (x.isVector3) {
        _target.copy(x);
      } else {
        _target.set(x, y, z);
      }
      var parent = this.parent;
      this.updateWorldMatrix(true, false);
      _position$3.setFromMatrixPosition(this.matrixWorld);
      if (this.isCamera || this.isLight) {
        _m1$1.lookAt(_position$3, _target, this.up);
      } else {
        _m1$1.lookAt(_target, _position$3, this.up);
      }
      this.quaternion.setFromRotationMatrix(_m1$1);
      if (parent) {
        _m1$1.extractRotation(parent.matrixWorld);
        _q1.setFromRotationMatrix(_m1$1);
        this.quaternion.premultiply(_q1.invert());
      }
    }
  }, {
    key: "add",
    value: function add(object) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }
        return this;
      }
      if (object === this) {
        console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
        return this;
      }
      if (object && object.isObject3D) {
        if (object.parent !== null) {
          object.parent.remove(object);
        }
        object.parent = this;
        this.children.push(object);
        object.dispatchEvent(_addedEvent);
      } else {
        console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
      }
      return this;
    }
  }, {
    key: "remove",
    value: function remove(object) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.remove(arguments[i]);
        }
        return this;
      }
      var index = this.children.indexOf(object);
      if (index !== -1) {
        object.parent = null;
        this.children.splice(index, 1);
        object.dispatchEvent(_removedEvent);
      }
      return this;
    }
  }, {
    key: "removeFromParent",
    value: function removeFromParent() {
      var parent = this.parent;
      if (parent !== null) {
        parent.remove(this);
      }
      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      return this.remove.apply(this, _toConsumableArray(this.children));
    }
  }, {
    key: "attach",
    value: function attach(object) {
      // adds object as a child of this, while maintaining the object's world transform

      // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

      this.updateWorldMatrix(true, false);
      _m1$1.copy(this.matrixWorld).invert();
      if (object.parent !== null) {
        object.parent.updateWorldMatrix(true, false);
        _m1$1.multiply(object.parent.matrixWorld);
      }
      object.applyMatrix4(_m1$1);
      this.add(object);
      object.updateWorldMatrix(false, true);
      return this;
    }
  }, {
    key: "getObjectById",
    value: function getObjectById(id) {
      return this.getObjectByProperty('id', id);
    }
  }, {
    key: "getObjectByName",
    value: function getObjectByName(name) {
      return this.getObjectByProperty('name', name);
    }
  }, {
    key: "getObjectByProperty",
    value: function getObjectByProperty(name, value) {
      if (this[name] === value) return this;
      for (var i = 0, l = this.children.length; i < l; i++) {
        var child = this.children[i];
        var object = child.getObjectByProperty(name, value);
        if (object !== undefined) {
          return object;
        }
      }
      return undefined;
    }
  }, {
    key: "getObjectsByProperty",
    value: function getObjectsByProperty(name, value) {
      var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      if (this[name] === value) result.push(this);
      var children = this.children;
      for (var i = 0, l = children.length; i < l; i++) {
        children[i].getObjectsByProperty(name, value, result);
      }
      return result;
    }
  }, {
    key: "getWorldPosition",
    value: function getWorldPosition(target) {
      this.updateWorldMatrix(true, false);
      return target.setFromMatrixPosition(this.matrixWorld);
    }
  }, {
    key: "getWorldQuaternion",
    value: function getWorldQuaternion(target) {
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, target, _scale$2);
      return target;
    }
  }, {
    key: "getWorldScale",
    value: function getWorldScale(target) {
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, _quaternion$2, target);
      return target;
    }
  }, {
    key: "getWorldDirection",
    value: function getWorldDirection(target) {
      this.updateWorldMatrix(true, false);
      var e = this.matrixWorld.elements;
      return target.set(e[8], e[9], e[10]).normalize();
    }
  }, {
    key: "raycast",
    value: function raycast( /* raycaster, intersects */) {}
  }, {
    key: "traverse",
    value: function traverse(callback) {
      callback(this);
      var children = this.children;
      for (var i = 0, l = children.length; i < l; i++) {
        children[i].traverse(callback);
      }
    }
  }, {
    key: "traverseVisible",
    value: function traverseVisible(callback) {
      if (this.visible === false) return;
      callback(this);
      var children = this.children;
      for (var i = 0, l = children.length; i < l; i++) {
        children[i].traverseVisible(callback);
      }
    }
  }, {
    key: "traverseAncestors",
    value: function traverseAncestors(callback) {
      var parent = this.parent;
      if (parent !== null) {
        callback(parent);
        parent.traverseAncestors(callback);
      }
    }
  }, {
    key: "updateMatrix",
    value: function updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale);
      this.matrixWorldNeedsUpdate = true;
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(force) {
      if (this.matrixAutoUpdate) this.updateMatrix();
      if (this.matrixWorldNeedsUpdate || force) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
        this.matrixWorldNeedsUpdate = false;
        force = true;
      }

      // update children

      var children = this.children;
      for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i];
        if (child.matrixWorldAutoUpdate === true || force === true) {
          child.updateMatrixWorld(force);
        }
      }
    }
  }, {
    key: "updateWorldMatrix",
    value: function updateWorldMatrix(updateParents, updateChildren) {
      var parent = this.parent;
      if (updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true) {
        parent.updateWorldMatrix(true, false);
      }
      if (this.matrixAutoUpdate) this.updateMatrix();
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }

      // update children

      if (updateChildren === true) {
        var children = this.children;
        for (var i = 0, l = children.length; i < l; i++) {
          var child = children[i];
          if (child.matrixWorldAutoUpdate === true) {
            child.updateWorldMatrix(false, true);
          }
        }
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      // meta is a string when called from JSON.stringify
      var isRootObject = meta === undefined || typeof meta === 'string';
      var output = {};

      // meta is a hash used to collect geometries, materials.
      // not providing it implies that this is the root object
      // being serialized.
      if (isRootObject) {
        // initialize meta obj
        meta = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
          nodes: {}
        };
        output.metadata = {
          version: 4.6,
          type: 'Object',
          generator: 'Object3D.toJSON'
        };
      }

      // standard Object3D serialization

      var object = {};
      object.uuid = this.uuid;
      object.type = this.type;
      if (this.name !== '') object.name = this.name;
      if (this.castShadow === true) object.castShadow = true;
      if (this.receiveShadow === true) object.receiveShadow = true;
      if (this.visible === false) object.visible = false;
      if (this.frustumCulled === false) object.frustumCulled = false;
      if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
      if (Object.keys(this.userData).length > 0) object.userData = this.userData;
      object.layers = this.layers.mask;
      object.matrix = this.matrix.toArray();
      object.up = this.up.toArray();
      if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;

      // object specific properties

      if (this.isInstancedMesh) {
        object.type = 'InstancedMesh';
        object.count = this.count;
        object.instanceMatrix = this.instanceMatrix.toJSON();
        if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
      }
      if (this.isBatchedMesh) {
        object.type = 'BatchedMesh';
        object.perObjectFrustumCulled = this.perObjectFrustumCulled;
        object.sortObjects = this.sortObjects;
        object.drawRanges = this._drawRanges;
        object.reservedRanges = this._reservedRanges;
        object.visibility = this._visibility;
        object.active = this._active;
        object.bounds = this._bounds.map(function (bound) {
          return {
            boxInitialized: bound.boxInitialized,
            boxMin: bound.box.min.toArray(),
            boxMax: bound.box.max.toArray(),
            sphereInitialized: bound.sphereInitialized,
            sphereRadius: bound.sphere.radius,
            sphereCenter: bound.sphere.center.toArray()
          };
        });
        object.maxGeometryCount = this._maxGeometryCount;
        object.maxVertexCount = this._maxVertexCount;
        object.maxIndexCount = this._maxIndexCount;
        object.geometryInitialized = this._geometryInitialized;
        object.geometryCount = this._geometryCount;
        object.matricesTexture = this._matricesTexture.toJSON(meta);
        if (this.boundingSphere !== null) {
          object.boundingSphere = {
            center: object.boundingSphere.center.toArray(),
            radius: object.boundingSphere.radius
          };
        }
        if (this.boundingBox !== null) {
          object.boundingBox = {
            min: object.boundingBox.min.toArray(),
            max: object.boundingBox.max.toArray()
          };
        }
      }

      //

      function serialize(library, element) {
        if (library[element.uuid] === undefined) {
          library[element.uuid] = element.toJSON(meta);
        }
        return element.uuid;
      }
      if (this.isScene) {
        if (this.background) {
          if (this.background.isColor) {
            object.background = this.background.toJSON();
          } else if (this.background.isTexture) {
            object.background = this.background.toJSON(meta).uuid;
          }
        }
        if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
          object.environment = this.environment.toJSON(meta).uuid;
        }
      } else if (this.isMesh || this.isLine || this.isPoints) {
        object.geometry = serialize(meta.geometries, this.geometry);
        var parameters = this.geometry.parameters;
        if (parameters !== undefined && parameters.shapes !== undefined) {
          var shapes = parameters.shapes;
          if (Array.isArray(shapes)) {
            for (var i = 0, l = shapes.length; i < l; i++) {
              var shape = shapes[i];
              serialize(meta.shapes, shape);
            }
          } else {
            serialize(meta.shapes, shapes);
          }
        }
      }
      if (this.isSkinnedMesh) {
        object.bindMode = this.bindMode;
        object.bindMatrix = this.bindMatrix.toArray();
        if (this.skeleton !== undefined) {
          serialize(meta.skeletons, this.skeleton);
          object.skeleton = this.skeleton.uuid;
        }
      }
      if (this.material !== undefined) {
        if (Array.isArray(this.material)) {
          var uuids = [];
          for (var _i3 = 0, _l2 = this.material.length; _i3 < _l2; _i3++) {
            uuids.push(serialize(meta.materials, this.material[_i3]));
          }
          object.material = uuids;
        } else {
          object.material = serialize(meta.materials, this.material);
        }
      }

      //

      if (this.children.length > 0) {
        object.children = [];
        for (var _i4 = 0; _i4 < this.children.length; _i4++) {
          object.children.push(this.children[_i4].toJSON(meta).object);
        }
      }

      //

      if (this.animations.length > 0) {
        object.animations = [];
        for (var _i5 = 0; _i5 < this.animations.length; _i5++) {
          var animation = this.animations[_i5];
          object.animations.push(serialize(meta.animations, animation));
        }
      }
      if (isRootObject) {
        var geometries = extractFromCache(meta.geometries);
        var materials = extractFromCache(meta.materials);
        var textures = extractFromCache(meta.textures);
        var images = extractFromCache(meta.images);
        var _shapes = extractFromCache(meta.shapes);
        var skeletons = extractFromCache(meta.skeletons);
        var animations = extractFromCache(meta.animations);
        var nodes = extractFromCache(meta.nodes);
        if (geometries.length > 0) output.geometries = geometries;
        if (materials.length > 0) output.materials = materials;
        if (textures.length > 0) output.textures = textures;
        if (images.length > 0) output.images = images;
        if (_shapes.length > 0) output.shapes = _shapes;
        if (skeletons.length > 0) output.skeletons = skeletons;
        if (animations.length > 0) output.animations = animations;
        if (nodes.length > 0) output.nodes = nodes;
      }
      output.object = object;
      return output;

      // extract data from the cache hash
      // remove metadata on each item
      // and return as array
      function extractFromCache(cache) {
        var values = [];
        for (var key in cache) {
          var data = cache[key];
          delete data.metadata;
          values.push(data);
        }
        return values;
      }
    }
  }, {
    key: "clone",
    value: function clone(recursive) {
      return new this.constructor().copy(this, recursive);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.name = source.name;
      this.up.copy(source.up);
      this.position.copy(source.position);
      this.rotation.order = source.rotation.order;
      this.quaternion.copy(source.quaternion);
      this.scale.copy(source.scale);
      this.matrix.copy(source.matrix);
      this.matrixWorld.copy(source.matrixWorld);
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
      this.layers.mask = source.layers.mask;
      this.visible = source.visible;
      this.castShadow = source.castShadow;
      this.receiveShadow = source.receiveShadow;
      this.frustumCulled = source.frustumCulled;
      this.renderOrder = source.renderOrder;
      this.animations = source.animations.slice();
      this.userData = JSON.parse(JSON.stringify(source.userData));
      if (recursive === true) {
        for (var i = 0; i < source.children.length; i++) {
          var child = source.children[i];
          this.add(child.clone());
        }
      }
      return this;
    }
  }]);
  return Object3D;
}(EventDispatcher);
Object3D.DEFAULT_UP = /*@__PURE__*/new Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
var _v0$1 = /*@__PURE__*/new Vector3();
var _v1$3 = /*@__PURE__*/new Vector3();
var _v2$2 = /*@__PURE__*/new Vector3();
var _v3$2 = /*@__PURE__*/new Vector3();
var _vab = /*@__PURE__*/new Vector3();
var _vac = /*@__PURE__*/new Vector3();
var _vbc = /*@__PURE__*/new Vector3();
var _vap = /*@__PURE__*/new Vector3();
var _vbp = /*@__PURE__*/new Vector3();
var _vcp = /*@__PURE__*/new Vector3();
var Triangle = /*#__PURE__*/function () {
  function Triangle() {
    var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
    var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
    var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();
    _classCallCheck(this, Triangle);
    this.a = a;
    this.b = b;
    this.c = c;
  }
  _createClass(Triangle, [{
    key: "set",
    value: function set(a, b, c) {
      this.a.copy(a);
      this.b.copy(b);
      this.c.copy(c);
      return this;
    }
  }, {
    key: "setFromPointsAndIndices",
    value: function setFromPointsAndIndices(points, i0, i1, i2) {
      this.a.copy(points[i0]);
      this.b.copy(points[i1]);
      this.c.copy(points[i2]);
      return this;
    }
  }, {
    key: "setFromAttributeAndIndices",
    value: function setFromAttributeAndIndices(attribute, i0, i1, i2) {
      this.a.fromBufferAttribute(attribute, i0);
      this.b.fromBufferAttribute(attribute, i1);
      this.c.fromBufferAttribute(attribute, i2);
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(triangle) {
      this.a.copy(triangle.a);
      this.b.copy(triangle.b);
      this.c.copy(triangle.c);
      return this;
    }
  }, {
    key: "getArea",
    value: function getArea() {
      _v0$1.subVectors(this.c, this.b);
      _v1$3.subVectors(this.a, this.b);
      return _v0$1.cross(_v1$3).length() * 0.5;
    }
  }, {
    key: "getMidpoint",
    value: function getMidpoint(target) {
      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
  }, {
    key: "getNormal",
    value: function getNormal(target) {
      return Triangle.getNormal(this.a, this.b, this.c, target);
    }
  }, {
    key: "getPlane",
    value: function getPlane(target) {
      return target.setFromCoplanarPoints(this.a, this.b, this.c);
    }
  }, {
    key: "getBarycoord",
    value: function getBarycoord(point, target) {
      return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    }
  }, {
    key: "getInterpolation",
    value: function getInterpolation(point, v1, v2, v3, target) {
      return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      return Triangle.containsPoint(point, this.a, this.b, this.c);
    }
  }, {
    key: "isFrontFacing",
    value: function isFrontFacing(direction) {
      return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      return box.intersectsTriangle(this);
    }
  }, {
    key: "closestPointToPoint",
    value: function closestPointToPoint(p, target) {
      var a = this.a,
        b = this.b,
        c = this.c;
      var v, w;

      // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
      // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
      // under the accompanying license; see chapter 5.1.5 for detailed explanation.
      // basically, we're distinguishing which of the voronoi regions of the triangle
      // the point lies in with the minimum amount of redundant computation.

      _vab.subVectors(b, a);
      _vac.subVectors(c, a);
      _vap.subVectors(p, a);
      var d1 = _vab.dot(_vap);
      var d2 = _vac.dot(_vap);
      if (d1 <= 0 && d2 <= 0) {
        // vertex region of A; barycentric coords (1, 0, 0)
        return target.copy(a);
      }
      _vbp.subVectors(p, b);
      var d3 = _vab.dot(_vbp);
      var d4 = _vac.dot(_vbp);
      if (d3 >= 0 && d4 <= d3) {
        // vertex region of B; barycentric coords (0, 1, 0)
        return target.copy(b);
      }
      var vc = d1 * d4 - d3 * d2;
      if (vc <= 0 && d1 >= 0 && d3 <= 0) {
        v = d1 / (d1 - d3);
        // edge region of AB; barycentric coords (1-v, v, 0)
        return target.copy(a).addScaledVector(_vab, v);
      }
      _vcp.subVectors(p, c);
      var d5 = _vab.dot(_vcp);
      var d6 = _vac.dot(_vcp);
      if (d6 >= 0 && d5 <= d6) {
        // vertex region of C; barycentric coords (0, 0, 1)
        return target.copy(c);
      }
      var vb = d5 * d2 - d1 * d6;
      if (vb <= 0 && d2 >= 0 && d6 <= 0) {
        w = d2 / (d2 - d6);
        // edge region of AC; barycentric coords (1-w, 0, w)
        return target.copy(a).addScaledVector(_vac, w);
      }
      var va = d3 * d6 - d5 * d4;
      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
        _vbc.subVectors(c, b);
        w = (d4 - d3) / (d4 - d3 + (d5 - d6));
        // edge region of BC; barycentric coords (0, 1-w, w)
        return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
      }

      // face region
      var denom = 1 / (va + vb + vc);
      // u = va * denom
      v = vb * denom;
      w = vc * denom;
      return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
    }
  }, {
    key: "equals",
    value: function equals(triangle) {
      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
  }], [{
    key: "getNormal",
    value: function getNormal(a, b, c, target) {
      target.subVectors(c, b);
      _v0$1.subVectors(a, b);
      target.cross(_v0$1);
      var targetLengthSq = target.lengthSq();
      if (targetLengthSq > 0) {
        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
      }
      return target.set(0, 0, 0);
    }

    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  }, {
    key: "getBarycoord",
    value: function getBarycoord(point, a, b, c, target) {
      _v0$1.subVectors(c, a);
      _v1$3.subVectors(b, a);
      _v2$2.subVectors(point, a);
      var dot00 = _v0$1.dot(_v0$1);
      var dot01 = _v0$1.dot(_v1$3);
      var dot02 = _v0$1.dot(_v2$2);
      var dot11 = _v1$3.dot(_v1$3);
      var dot12 = _v1$3.dot(_v2$2);
      var denom = dot00 * dot11 - dot01 * dot01;

      // collinear or singular triangle
      if (denom === 0) {
        target.set(0, 0, 0);
        return null;
      }
      var invDenom = 1 / denom;
      var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

      // barycentric coordinates must always sum to 1
      return target.set(1 - u - v, v, u);
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(point, a, b, c) {
      // if the triangle is degenerate then we can't contain a point
      if (this.getBarycoord(point, a, b, c, _v3$2) === null) {
        return false;
      }
      return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
    }
  }, {
    key: "getInterpolation",
    value: function getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
      if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {
        target.x = 0;
        target.y = 0;
        if ('z' in target) target.z = 0;
        if ('w' in target) target.w = 0;
        return null;
      }
      target.setScalar(0);
      target.addScaledVector(v1, _v3$2.x);
      target.addScaledVector(v2, _v3$2.y);
      target.addScaledVector(v3, _v3$2.z);
      return target;
    }
  }, {
    key: "isFrontFacing",
    value: function isFrontFacing(a, b, c, direction) {
      _v0$1.subVectors(c, b);
      _v1$3.subVectors(a, b);

      // strictly front facing
      return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
    }
  }]);
  return Triangle;
}();
var _colorKeywords = {
  'aliceblue': 0xF0F8FF,
  'antiquewhite': 0xFAEBD7,
  'aqua': 0x00FFFF,
  'aquamarine': 0x7FFFD4,
  'azure': 0xF0FFFF,
  'beige': 0xF5F5DC,
  'bisque': 0xFFE4C4,
  'black': 0x000000,
  'blanchedalmond': 0xFFEBCD,
  'blue': 0x0000FF,
  'blueviolet': 0x8A2BE2,
  'brown': 0xA52A2A,
  'burlywood': 0xDEB887,
  'cadetblue': 0x5F9EA0,
  'chartreuse': 0x7FFF00,
  'chocolate': 0xD2691E,
  'coral': 0xFF7F50,
  'cornflowerblue': 0x6495ED,
  'cornsilk': 0xFFF8DC,
  'crimson': 0xDC143C,
  'cyan': 0x00FFFF,
  'darkblue': 0x00008B,
  'darkcyan': 0x008B8B,
  'darkgoldenrod': 0xB8860B,
  'darkgray': 0xA9A9A9,
  'darkgreen': 0x006400,
  'darkgrey': 0xA9A9A9,
  'darkkhaki': 0xBDB76B,
  'darkmagenta': 0x8B008B,
  'darkolivegreen': 0x556B2F,
  'darkorange': 0xFF8C00,
  'darkorchid': 0x9932CC,
  'darkred': 0x8B0000,
  'darksalmon': 0xE9967A,
  'darkseagreen': 0x8FBC8F,
  'darkslateblue': 0x483D8B,
  'darkslategray': 0x2F4F4F,
  'darkslategrey': 0x2F4F4F,
  'darkturquoise': 0x00CED1,
  'darkviolet': 0x9400D3,
  'deeppink': 0xFF1493,
  'deepskyblue': 0x00BFFF,
  'dimgray': 0x696969,
  'dimgrey': 0x696969,
  'dodgerblue': 0x1E90FF,
  'firebrick': 0xB22222,
  'floralwhite': 0xFFFAF0,
  'forestgreen': 0x228B22,
  'fuchsia': 0xFF00FF,
  'gainsboro': 0xDCDCDC,
  'ghostwhite': 0xF8F8FF,
  'gold': 0xFFD700,
  'goldenrod': 0xDAA520,
  'gray': 0x808080,
  'green': 0x008000,
  'greenyellow': 0xADFF2F,
  'grey': 0x808080,
  'honeydew': 0xF0FFF0,
  'hotpink': 0xFF69B4,
  'indianred': 0xCD5C5C,
  'indigo': 0x4B0082,
  'ivory': 0xFFFFF0,
  'khaki': 0xF0E68C,
  'lavender': 0xE6E6FA,
  'lavenderblush': 0xFFF0F5,
  'lawngreen': 0x7CFC00,
  'lemonchiffon': 0xFFFACD,
  'lightblue': 0xADD8E6,
  'lightcoral': 0xF08080,
  'lightcyan': 0xE0FFFF,
  'lightgoldenrodyellow': 0xFAFAD2,
  'lightgray': 0xD3D3D3,
  'lightgreen': 0x90EE90,
  'lightgrey': 0xD3D3D3,
  'lightpink': 0xFFB6C1,
  'lightsalmon': 0xFFA07A,
  'lightseagreen': 0x20B2AA,
  'lightskyblue': 0x87CEFA,
  'lightslategray': 0x778899,
  'lightslategrey': 0x778899,
  'lightsteelblue': 0xB0C4DE,
  'lightyellow': 0xFFFFE0,
  'lime': 0x00FF00,
  'limegreen': 0x32CD32,
  'linen': 0xFAF0E6,
  'magenta': 0xFF00FF,
  'maroon': 0x800000,
  'mediumaquamarine': 0x66CDAA,
  'mediumblue': 0x0000CD,
  'mediumorchid': 0xBA55D3,
  'mediumpurple': 0x9370DB,
  'mediumseagreen': 0x3CB371,
  'mediumslateblue': 0x7B68EE,
  'mediumspringgreen': 0x00FA9A,
  'mediumturquoise': 0x48D1CC,
  'mediumvioletred': 0xC71585,
  'midnightblue': 0x191970,
  'mintcream': 0xF5FFFA,
  'mistyrose': 0xFFE4E1,
  'moccasin': 0xFFE4B5,
  'navajowhite': 0xFFDEAD,
  'navy': 0x000080,
  'oldlace': 0xFDF5E6,
  'olive': 0x808000,
  'olivedrab': 0x6B8E23,
  'orange': 0xFFA500,
  'orangered': 0xFF4500,
  'orchid': 0xDA70D6,
  'palegoldenrod': 0xEEE8AA,
  'palegreen': 0x98FB98,
  'paleturquoise': 0xAFEEEE,
  'palevioletred': 0xDB7093,
  'papayawhip': 0xFFEFD5,
  'peachpuff': 0xFFDAB9,
  'peru': 0xCD853F,
  'pink': 0xFFC0CB,
  'plum': 0xDDA0DD,
  'powderblue': 0xB0E0E6,
  'purple': 0x800080,
  'rebeccapurple': 0x663399,
  'red': 0xFF0000,
  'rosybrown': 0xBC8F8F,
  'royalblue': 0x4169E1,
  'saddlebrown': 0x8B4513,
  'salmon': 0xFA8072,
  'sandybrown': 0xF4A460,
  'seagreen': 0x2E8B57,
  'seashell': 0xFFF5EE,
  'sienna': 0xA0522D,
  'silver': 0xC0C0C0,
  'skyblue': 0x87CEEB,
  'slateblue': 0x6A5ACD,
  'slategray': 0x708090,
  'slategrey': 0x708090,
  'snow': 0xFFFAFA,
  'springgreen': 0x00FF7F,
  'steelblue': 0x4682B4,
  'tan': 0xD2B48C,
  'teal': 0x008080,
  'thistle': 0xD8BFD8,
  'tomato': 0xFF6347,
  'turquoise': 0x40E0D0,
  'violet': 0xEE82EE,
  'wheat': 0xF5DEB3,
  'white': 0xFFFFFF,
  'whitesmoke': 0xF5F5F5,
  'yellow': 0xFFFF00,
  'yellowgreen': 0x9ACD32
};
var _hslA = {
  h: 0,
  s: 0,
  l: 0
};
var _hslB = {
  h: 0,
  s: 0,
  l: 0
};
function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}
var Color = /*#__PURE__*/function (_Symbol$iterator6) {
  function Color(r, g, b) {
    _classCallCheck(this, Color);
    this.isColor = true;
    this.r = 1;
    this.g = 1;
    this.b = 1;
    return this.set(r, g, b);
  }
  _createClass(Color, [{
    key: "set",
    value: function set(r, g, b) {
      if (g === undefined && b === undefined) {
        // r is THREE.Color, hex or string

        var _value = r;
        if (_value && _value.isColor) {
          this.copy(_value);
        } else if (typeof _value === 'number') {
          this.setHex(_value);
        } else if (typeof _value === 'string') {
          this.setStyle(_value);
        }
      } else {
        this.setRGB(r, g, b);
      }
      return this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(scalar) {
      this.r = scalar;
      this.g = scalar;
      this.b = scalar;
      return this;
    }
  }, {
    key: "setHex",
    value: function setHex(hex) {
      var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SRGBColorSpace;
      hex = Math.floor(hex);
      this.r = (hex >> 16 & 255) / 255;
      this.g = (hex >> 8 & 255) / 255;
      this.b = (hex & 255) / 255;
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
  }, {
    key: "setRGB",
    value: function setRGB(r, g, b) {
      var colorSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ColorManagement.workingColorSpace;
      this.r = r;
      this.g = g;
      this.b = b;
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
  }, {
    key: "setHSL",
    value: function setHSL(h, s, l) {
      var colorSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ColorManagement.workingColorSpace;
      // h,s,l ranges are in 0.0 - 1.0
      h = euclideanModulo(h, 1);
      s = clamp(s, 0, 1);
      l = clamp(l, 0, 1);
      if (s === 0) {
        this.r = this.g = this.b = l;
      } else {
        var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        var q = 2 * l - p;
        this.r = hue2rgb(q, p, h + 1 / 3);
        this.g = hue2rgb(q, p, h);
        this.b = hue2rgb(q, p, h - 1 / 3);
      }
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
  }, {
    key: "setStyle",
    value: function setStyle(style) {
      var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SRGBColorSpace;
      function handleAlpha(string) {
        if (string === undefined) return;
        if (parseFloat(string) < 1) {
          console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
        }
      }
      var m;
      if (m = /^(\w+)\(([^\)]*)\)/.exec(style)) {
        // rgb / hsl

        var color;
        var name = m[1];
        var components = m[2];
        switch (name) {
          case 'rgb':
          case 'rgba':
            if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              // rgb(255,0,0) rgba(255,0,0,0.5)

              handleAlpha(color[4]);
              return this.setRGB(Math.min(255, parseInt(color[1], 10)) / 255, Math.min(255, parseInt(color[2], 10)) / 255, Math.min(255, parseInt(color[3], 10)) / 255, colorSpace);
            }
            if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)

              handleAlpha(color[4]);
              return this.setRGB(Math.min(100, parseInt(color[1], 10)) / 100, Math.min(100, parseInt(color[2], 10)) / 100, Math.min(100, parseInt(color[3], 10)) / 100, colorSpace);
            }
            break;
          case 'hsl':
          case 'hsla':
            if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              // hsl(120,50%,50%) hsla(120,50%,50%,0.5)

              handleAlpha(color[4]);
              return this.setHSL(parseFloat(color[1]) / 360, parseFloat(color[2]) / 100, parseFloat(color[3]) / 100, colorSpace);
            }
            break;
          default:
            console.warn('THREE.Color: Unknown color model ' + style);
        }
      } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
        // hex color

        var hex = m[1];
        var size = hex.length;
        if (size === 3) {
          // #ff0
          return this.setRGB(parseInt(hex.charAt(0), 16) / 15, parseInt(hex.charAt(1), 16) / 15, parseInt(hex.charAt(2), 16) / 15, colorSpace);
        } else if (size === 6) {
          // #ff0000
          return this.setHex(parseInt(hex, 16), colorSpace);
        } else {
          console.warn('THREE.Color: Invalid hex color ' + style);
        }
      } else if (style && style.length > 0) {
        return this.setColorName(style, colorSpace);
      }
      return this;
    }
  }, {
    key: "setColorName",
    value: function setColorName(style) {
      var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SRGBColorSpace;
      // color keywords
      var hex = _colorKeywords[style.toLowerCase()];
      if (hex !== undefined) {
        // red
        this.setHex(hex, colorSpace);
      } else {
        // unknown color
        console.warn('THREE.Color: Unknown color ' + style);
      }
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
  }, {
    key: "copy",
    value: function copy(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      return this;
    }
  }, {
    key: "copySRGBToLinear",
    value: function copySRGBToLinear(color) {
      this.r = SRGBToLinear(color.r);
      this.g = SRGBToLinear(color.g);
      this.b = SRGBToLinear(color.b);
      return this;
    }
  }, {
    key: "copyLinearToSRGB",
    value: function copyLinearToSRGB(color) {
      this.r = LinearToSRGB(color.r);
      this.g = LinearToSRGB(color.g);
      this.b = LinearToSRGB(color.b);
      return this;
    }
  }, {
    key: "convertSRGBToLinear",
    value: function convertSRGBToLinear() {
      this.copySRGBToLinear(this);
      return this;
    }
  }, {
    key: "convertLinearToSRGB",
    value: function convertLinearToSRGB() {
      this.copyLinearToSRGB(this);
      return this;
    }
  }, {
    key: "getHex",
    value: function getHex() {
      var colorSpace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SRGBColorSpace;
      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));
    }
  }, {
    key: "getHexString",
    value: function getHexString() {
      var colorSpace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SRGBColorSpace;
      return ('000000' + this.getHex(colorSpace).toString(16)).slice(-6);
    }
  }, {
    key: "getHSL",
    value: function getHSL(target) {
      var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ColorManagement.workingColorSpace;
      // h,s,l ranges are in 0.0 - 1.0

      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      var r = _color.r,
        g = _color.g,
        b = _color.b;
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var hue, saturation;
      var lightness = (min + max) / 2.0;
      if (min === max) {
        hue = 0;
        saturation = 0;
      } else {
        var delta = max - min;
        saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
        switch (max) {
          case r:
            hue = (g - b) / delta + (g < b ? 6 : 0);
            break;
          case g:
            hue = (b - r) / delta + 2;
            break;
          case b:
            hue = (r - g) / delta + 4;
            break;
        }
        hue /= 6;
      }
      target.h = hue;
      target.s = saturation;
      target.l = lightness;
      return target;
    }
  }, {
    key: "getRGB",
    value: function getRGB(target) {
      var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ColorManagement.workingColorSpace;
      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      target.r = _color.r;
      target.g = _color.g;
      target.b = _color.b;
      return target;
    }
  }, {
    key: "getStyle",
    value: function getStyle() {
      var colorSpace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SRGBColorSpace;
      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      var r = _color.r,
        g = _color.g,
        b = _color.b;
      if (colorSpace !== SRGBColorSpace) {
        // Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
        return "color(".concat(colorSpace, " ").concat(r.toFixed(3), " ").concat(g.toFixed(3), " ").concat(b.toFixed(3), ")");
      }
      return "rgb(".concat(Math.round(r * 255), ",").concat(Math.round(g * 255), ",").concat(Math.round(b * 255), ")");
    }
  }, {
    key: "offsetHSL",
    value: function offsetHSL(h, s, l) {
      this.getHSL(_hslA);
      return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);
    }
  }, {
    key: "add",
    value: function add(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      return this;
    }
  }, {
    key: "addColors",
    value: function addColors(color1, color2) {
      this.r = color1.r + color2.r;
      this.g = color1.g + color2.g;
      this.b = color1.b + color2.b;
      return this;
    }
  }, {
    key: "addScalar",
    value: function addScalar(s) {
      this.r += s;
      this.g += s;
      this.b += s;
      return this;
    }
  }, {
    key: "sub",
    value: function sub(color) {
      this.r = Math.max(0, this.r - color.r);
      this.g = Math.max(0, this.g - color.g);
      this.b = Math.max(0, this.b - color.b);
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(color) {
      this.r *= color.r;
      this.g *= color.g;
      this.b *= color.b;
      return this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(s) {
      this.r *= s;
      this.g *= s;
      this.b *= s;
      return this;
    }
  }, {
    key: "lerp",
    value: function lerp(color, alpha) {
      this.r += (color.r - this.r) * alpha;
      this.g += (color.g - this.g) * alpha;
      this.b += (color.b - this.b) * alpha;
      return this;
    }
  }, {
    key: "lerpColors",
    value: function lerpColors(color1, color2, alpha) {
      this.r = color1.r + (color2.r - color1.r) * alpha;
      this.g = color1.g + (color2.g - color1.g) * alpha;
      this.b = color1.b + (color2.b - color1.b) * alpha;
      return this;
    }
  }, {
    key: "lerpHSL",
    value: function lerpHSL(color, alpha) {
      this.getHSL(_hslA);
      color.getHSL(_hslB);
      var h = lerp(_hslA.h, _hslB.h, alpha);
      var s = lerp(_hslA.s, _hslB.s, alpha);
      var l = lerp(_hslA.l, _hslB.l, alpha);
      this.setHSL(h, s, l);
      return this;
    }
  }, {
    key: "setFromVector3",
    value: function setFromVector3(v) {
      this.r = v.x;
      this.g = v.y;
      this.b = v.z;
      return this;
    }
  }, {
    key: "applyMatrix3",
    value: function applyMatrix3(m) {
      var r = this.r,
        g = this.g,
        b = this.b;
      var e = m.elements;
      this.r = e[0] * r + e[3] * g + e[6] * b;
      this.g = e[1] * r + e[4] * g + e[7] * b;
      this.b = e[2] * r + e[5] * g + e[8] * b;
      return this;
    }
  }, {
    key: "equals",
    value: function equals(c) {
      return c.r === this.r && c.g === this.g && c.b === this.b;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.r = array[offset];
      this.g = array[offset + 1];
      this.b = array[offset + 2];
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this.r;
      array[offset + 1] = this.g;
      array[offset + 2] = this.b;
      return array;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(attribute, index) {
      this.r = attribute.getX(index);
      this.g = attribute.getY(index);
      this.b = attribute.getZ(index);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.getHex();
    }
  }, {
    key: _Symbol$iterator6,
    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {
      return _regeneratorRuntime().wrap(function value$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return this.r;
          case 2:
            _context6.next = 4;
            return this.g;
          case 4:
            _context6.next = 6;
            return this.b;
          case 6:
          case "end":
            return _context6.stop();
        }
      }, value, this);
    })
  }]);
  return Color;
}(Symbol.iterator);
var _color = /*@__PURE__*/new Color();
Color.NAMES = _colorKeywords;
var _materialId = 0;
var Material = /*#__PURE__*/function (_EventDispatcher3) {
  _inherits(Material, _EventDispatcher3);
  var _super3 = _createSuper(Material);
  function Material() {
    var _this3;
    _classCallCheck(this, Material);
    _this3 = _super3.call(this);
    _this3.isMaterial = true;
    Object.defineProperty(_assertThisInitialized(_this3), 'id', {
      value: _materialId++
    });
    _this3.uuid = generateUUID();
    _this3.name = '';
    _this3.type = 'Material';
    _this3.blending = NormalBlending;
    _this3.side = FrontSide;
    _this3.vertexColors = false;
    _this3.opacity = 1;
    _this3.transparent = false;
    _this3.alphaHash = false;
    _this3.blendSrc = SrcAlphaFactor;
    _this3.blendDst = OneMinusSrcAlphaFactor;
    _this3.blendEquation = AddEquation;
    _this3.blendSrcAlpha = null;
    _this3.blendDstAlpha = null;
    _this3.blendEquationAlpha = null;
    _this3.blendColor = new Color(0, 0, 0);
    _this3.blendAlpha = 0;
    _this3.depthFunc = LessEqualDepth;
    _this3.depthTest = true;
    _this3.depthWrite = true;
    _this3.stencilWriteMask = 0xff;
    _this3.stencilFunc = AlwaysStencilFunc;
    _this3.stencilRef = 0;
    _this3.stencilFuncMask = 0xff;
    _this3.stencilFail = KeepStencilOp;
    _this3.stencilZFail = KeepStencilOp;
    _this3.stencilZPass = KeepStencilOp;
    _this3.stencilWrite = false;
    _this3.clippingPlanes = null;
    _this3.clipIntersection = false;
    _this3.clipShadows = false;
    _this3.shadowSide = null;
    _this3.colorWrite = true;
    _this3.precision = null; // override the renderer's default precision for this material

    _this3.polygonOffset = false;
    _this3.polygonOffsetFactor = 0;
    _this3.polygonOffsetUnits = 0;
    _this3.dithering = false;
    _this3.alphaToCoverage = false;
    _this3.premultipliedAlpha = false;
    _this3.forceSinglePass = false;
    _this3.visible = true;
    _this3.toneMapped = true;
    _this3.userData = {};
    _this3.version = 0;
    _this3._alphaTest = 0;
    return _this3;
  }
  _createClass(Material, [{
    key: "alphaTest",
    get: function get() {
      return this._alphaTest;
    },
    set: function set(value) {
      if (this._alphaTest > 0 !== value > 0) {
        this.version++;
      }
      this._alphaTest = value;
    }
  }, {
    key: "onBuild",
    value: function onBuild( /* shaderobject, renderer */) {}
  }, {
    key: "onBeforeRender",
    value: function onBeforeRender( /* renderer, scene, camera, geometry, object, group */) {}
  }, {
    key: "onBeforeCompile",
    value: function onBeforeCompile( /* shaderobject, renderer */) {}
  }, {
    key: "customProgramCacheKey",
    value: function customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
  }, {
    key: "setValues",
    value: function setValues(values) {
      if (values === undefined) return;
      for (var key in values) {
        var newValue = values[key];
        if (newValue === undefined) {
          console.warn("THREE.Material: parameter '".concat(key, "' has value of undefined."));
          continue;
        }
        var currentValue = this[key];
        if (currentValue === undefined) {
          console.warn("THREE.Material: '".concat(key, "' is not a property of THREE.").concat(this.type, "."));
          continue;
        }
        if (currentValue && currentValue.isColor) {
          currentValue.set(newValue);
        } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
          currentValue.copy(newValue);
        } else {
          this[key] = newValue;
        }
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var isRootObject = meta === undefined || typeof meta === 'string';
      if (isRootObject) {
        meta = {
          textures: {},
          images: {}
        };
      }
      var data = {
        metadata: {
          version: 4.6,
          type: 'Material',
          generator: 'Material.toJSON'
        }
      };

      // standard Material serialization
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== '') data.name = this.name;
      if (this.color && this.color.isColor) data.color = this.color.getHex();
      if (this.roughness !== undefined) data.roughness = this.roughness;
      if (this.metalness !== undefined) data.metalness = this.metalness;
      if (this.sheen !== undefined) data.sheen = this.sheen;
      if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
      if (this.sheenRoughness !== undefined) data.sheenRoughness = this.sheenRoughness;
      if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
      if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
      if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
      if (this.specularIntensity !== undefined) data.specularIntensity = this.specularIntensity;
      if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
      if (this.shininess !== undefined) data.shininess = this.shininess;
      if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
      if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;
      if (this.clearcoatMap && this.clearcoatMap.isTexture) {
        data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
      }
      if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
        data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
      }
      if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
      }
      if (this.iridescence !== undefined) data.iridescence = this.iridescence;
      if (this.iridescenceIOR !== undefined) data.iridescenceIOR = this.iridescenceIOR;
      if (this.iridescenceThicknessRange !== undefined) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
      if (this.iridescenceMap && this.iridescenceMap.isTexture) {
        data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
      }
      if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
        data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
      }
      if (this.anisotropy !== undefined) data.anisotropy = this.anisotropy;
      if (this.anisotropyRotation !== undefined) data.anisotropyRotation = this.anisotropyRotation;
      if (this.anisotropyMap && this.anisotropyMap.isTexture) {
        data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
      }
      if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
      if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
      if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
      if (this.lightMap && this.lightMap.isTexture) {
        data.lightMap = this.lightMap.toJSON(meta).uuid;
        data.lightMapIntensity = this.lightMapIntensity;
      }
      if (this.aoMap && this.aoMap.isTexture) {
        data.aoMap = this.aoMap.toJSON(meta).uuid;
        data.aoMapIntensity = this.aoMapIntensity;
      }
      if (this.bumpMap && this.bumpMap.isTexture) {
        data.bumpMap = this.bumpMap.toJSON(meta).uuid;
        data.bumpScale = this.bumpScale;
      }
      if (this.normalMap && this.normalMap.isTexture) {
        data.normalMap = this.normalMap.toJSON(meta).uuid;
        data.normalMapType = this.normalMapType;
        data.normalScale = this.normalScale.toArray();
      }
      if (this.displacementMap && this.displacementMap.isTexture) {
        data.displacementMap = this.displacementMap.toJSON(meta).uuid;
        data.displacementScale = this.displacementScale;
        data.displacementBias = this.displacementBias;
      }
      if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
      if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
      if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
      if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
      if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
      if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
      if (this.envMap && this.envMap.isTexture) {
        data.envMap = this.envMap.toJSON(meta).uuid;
        if (this.combine !== undefined) data.combine = this.combine;
      }
      if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
      if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;
      if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;
      if (this.gradientMap && this.gradientMap.isTexture) {
        data.gradientMap = this.gradientMap.toJSON(meta).uuid;
      }
      if (this.transmission !== undefined) data.transmission = this.transmission;
      if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
      if (this.thickness !== undefined) data.thickness = this.thickness;
      if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
      if (this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
      if (this.attenuationColor !== undefined) data.attenuationColor = this.attenuationColor.getHex();
      if (this.size !== undefined) data.size = this.size;
      if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
      if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
      if (this.blending !== NormalBlending) data.blending = this.blending;
      if (this.side !== FrontSide) data.side = this.side;
      if (this.vertexColors === true) data.vertexColors = true;
      if (this.opacity < 1) data.opacity = this.opacity;
      if (this.transparent === true) data.transparent = true;
      if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;
      if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;
      if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;
      if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;
      if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;
      if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;
      if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();
      if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;
      if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;
      if (this.depthTest === false) data.depthTest = this.depthTest;
      if (this.depthWrite === false) data.depthWrite = this.depthWrite;
      if (this.colorWrite === false) data.colorWrite = this.colorWrite;
      if (this.stencilWriteMask !== 0xff) data.stencilWriteMask = this.stencilWriteMask;
      if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;
      if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;
      if (this.stencilFuncMask !== 0xff) data.stencilFuncMask = this.stencilFuncMask;
      if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;
      if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;
      if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;
      if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;

      // rotation (SpriteMaterial)
      if (this.rotation !== undefined && this.rotation !== 0) data.rotation = this.rotation;
      if (this.polygonOffset === true) data.polygonOffset = true;
      if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
      if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
      if (this.linewidth !== undefined && this.linewidth !== 1) data.linewidth = this.linewidth;
      if (this.dashSize !== undefined) data.dashSize = this.dashSize;
      if (this.gapSize !== undefined) data.gapSize = this.gapSize;
      if (this.scale !== undefined) data.scale = this.scale;
      if (this.dithering === true) data.dithering = true;
      if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
      if (this.alphaHash === true) data.alphaHash = true;
      if (this.alphaToCoverage === true) data.alphaToCoverage = true;
      if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;
      if (this.forceSinglePass === true) data.forceSinglePass = true;
      if (this.wireframe === true) data.wireframe = true;
      if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
      if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
      if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
      if (this.flatShading === true) data.flatShading = true;
      if (this.visible === false) data.visible = false;
      if (this.toneMapped === false) data.toneMapped = false;
      if (this.fog === false) data.fog = false;
      if (Object.keys(this.userData).length > 0) data.userData = this.userData;

      // TODO: Copied from Object3D.toJSON

      function extractFromCache(cache) {
        var values = [];
        for (var key in cache) {
          var _data2 = cache[key];
          delete _data2.metadata;
          values.push(_data2);
        }
        return values;
      }
      if (isRootObject) {
        var textures = extractFromCache(meta.textures);
        var images = extractFromCache(meta.images);
        if (textures.length > 0) data.textures = textures;
        if (images.length > 0) data.images = images;
      }
      return data;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.name = source.name;
      this.blending = source.blending;
      this.side = source.side;
      this.vertexColors = source.vertexColors;
      this.opacity = source.opacity;
      this.transparent = source.transparent;
      this.blendSrc = source.blendSrc;
      this.blendDst = source.blendDst;
      this.blendEquation = source.blendEquation;
      this.blendSrcAlpha = source.blendSrcAlpha;
      this.blendDstAlpha = source.blendDstAlpha;
      this.blendEquationAlpha = source.blendEquationAlpha;
      this.blendColor.copy(source.blendColor);
      this.blendAlpha = source.blendAlpha;
      this.depthFunc = source.depthFunc;
      this.depthTest = source.depthTest;
      this.depthWrite = source.depthWrite;
      this.stencilWriteMask = source.stencilWriteMask;
      this.stencilFunc = source.stencilFunc;
      this.stencilRef = source.stencilRef;
      this.stencilFuncMask = source.stencilFuncMask;
      this.stencilFail = source.stencilFail;
      this.stencilZFail = source.stencilZFail;
      this.stencilZPass = source.stencilZPass;
      this.stencilWrite = source.stencilWrite;
      var srcPlanes = source.clippingPlanes;
      var dstPlanes = null;
      if (srcPlanes !== null) {
        var n = srcPlanes.length;
        dstPlanes = new Array(n);
        for (var i = 0; i !== n; ++i) {
          dstPlanes[i] = srcPlanes[i].clone();
        }
      }
      this.clippingPlanes = dstPlanes;
      this.clipIntersection = source.clipIntersection;
      this.clipShadows = source.clipShadows;
      this.shadowSide = source.shadowSide;
      this.colorWrite = source.colorWrite;
      this.precision = source.precision;
      this.polygonOffset = source.polygonOffset;
      this.polygonOffsetFactor = source.polygonOffsetFactor;
      this.polygonOffsetUnits = source.polygonOffsetUnits;
      this.dithering = source.dithering;
      this.alphaTest = source.alphaTest;
      this.alphaHash = source.alphaHash;
      this.alphaToCoverage = source.alphaToCoverage;
      this.premultipliedAlpha = source.premultipliedAlpha;
      this.forceSinglePass = source.forceSinglePass;
      this.visible = source.visible;
      this.toneMapped = source.toneMapped;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      return this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
    }
  }, {
    key: "needsUpdate",
    set: function set(value) {
      if (value === true) this.version++;
    }
  }]);
  return Material;
}(EventDispatcher);
var MeshBasicMaterial = /*#__PURE__*/function (_Material) {
  _inherits(MeshBasicMaterial, _Material);
  var _super4 = _createSuper(MeshBasicMaterial);
  function MeshBasicMaterial(parameters) {
    var _this4;
    _classCallCheck(this, MeshBasicMaterial);
    _this4 = _super4.call(this);
    _this4.isMeshBasicMaterial = true;
    _this4.type = 'MeshBasicMaterial';
    _this4.color = new Color(0xffffff); // emissive

    _this4.map = null;
    _this4.lightMap = null;
    _this4.lightMapIntensity = 1.0;
    _this4.aoMap = null;
    _this4.aoMapIntensity = 1.0;
    _this4.specularMap = null;
    _this4.alphaMap = null;
    _this4.envMap = null;
    _this4.combine = MultiplyOperation;
    _this4.reflectivity = 1;
    _this4.refractionRatio = 0.98;
    _this4.wireframe = false;
    _this4.wireframeLinewidth = 1;
    _this4.wireframeLinecap = 'round';
    _this4.wireframeLinejoin = 'round';
    _this4.fog = true;
    _this4.setValues(parameters);
    return _this4;
  }
  _createClass(MeshBasicMaterial, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(MeshBasicMaterial.prototype), "copy", this).call(this, source);
      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.fog = source.fog;
      return this;
    }
  }]);
  return MeshBasicMaterial;
}(Material);
var _vector$9 = /*@__PURE__*/new Vector3();
var _vector2$1 = /*@__PURE__*/new Vector2();
var BufferAttribute = /*#__PURE__*/function () {
  function BufferAttribute(array, itemSize) {
    var normalized = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    _classCallCheck(this, BufferAttribute);
    if (Array.isArray(array)) {
      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    }
    this.isBufferAttribute = true;
    this.name = '';
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== undefined ? array.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = StaticDrawUsage;
    this._updateRange = {
      offset: 0,
      count: -1
    };
    this.updateRanges = [];
    this.gpuType = FloatType;
    this.version = 0;
  }
  _createClass(BufferAttribute, [{
    key: "onUploadCallback",
    value: function onUploadCallback() {}
  }, {
    key: "needsUpdate",
    set: function set(value) {
      if (value === true) this.version++;
    }
  }, {
    key: "updateRange",
    get: function get() {
      warnOnce('THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.'); // @deprecated, r159
      return this._updateRange;
    }
  }, {
    key: "setUsage",
    value: function setUsage(value) {
      this.usage = value;
      return this;
    }
  }, {
    key: "addUpdateRange",
    value: function addUpdateRange(start, count) {
      this.updateRanges.push({
        start: start,
        count: count
      });
    }
  }, {
    key: "clearUpdateRanges",
    value: function clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.name = source.name;
      this.array = new source.array.constructor(source.array);
      this.itemSize = source.itemSize;
      this.count = source.count;
      this.normalized = source.normalized;
      this.usage = source.usage;
      this.gpuType = source.gpuType;
      return this;
    }
  }, {
    key: "copyAt",
    value: function copyAt(index1, attribute, index2) {
      index1 *= this.itemSize;
      index2 *= attribute.itemSize;
      for (var i = 0, l = this.itemSize; i < l; i++) {
        this.array[index1 + i] = attribute.array[index2 + i];
      }
      return this;
    }
  }, {
    key: "copyArray",
    value: function copyArray(array) {
      this.array.set(array);
      return this;
    }
  }, {
    key: "applyMatrix3",
    value: function applyMatrix3(m) {
      if (this.itemSize === 2) {
        for (var i = 0, l = this.count; i < l; i++) {
          _vector2$1.fromBufferAttribute(this, i);
          _vector2$1.applyMatrix3(m);
          this.setXY(i, _vector2$1.x, _vector2$1.y);
        }
      } else if (this.itemSize === 3) {
        for (var _i6 = 0, _l3 = this.count; _i6 < _l3; _i6++) {
          _vector$9.fromBufferAttribute(this, _i6);
          _vector$9.applyMatrix3(m);
          this.setXYZ(_i6, _vector$9.x, _vector$9.y, _vector$9.z);
        }
      }
      return this;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(m) {
      for (var i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.applyMatrix4(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
  }, {
    key: "applyNormalMatrix",
    value: function applyNormalMatrix(m) {
      for (var i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.applyNormalMatrix(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(m) {
      for (var i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.transformDirection(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
  }, {
    key: "set",
    value: function set(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Matching BufferAttribute constructor, do not normalize the array.
      this.array.set(value, offset);
      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(index, component) {
      var value = this.array[index * this.itemSize + component];
      if (this.normalized) value = denormalize(value, this.array);
      return value;
    }
  }, {
    key: "setComponent",
    value: function setComponent(index, component, value) {
      if (this.normalized) value = normalize(value, this.array);
      this.array[index * this.itemSize + component] = value;
      return this;
    }
  }, {
    key: "getX",
    value: function getX(index) {
      var x = this.array[index * this.itemSize];
      if (this.normalized) x = denormalize(x, this.array);
      return x;
    }
  }, {
    key: "setX",
    value: function setX(index, x) {
      if (this.normalized) x = normalize(x, this.array);
      this.array[index * this.itemSize] = x;
      return this;
    }
  }, {
    key: "getY",
    value: function getY(index) {
      var y = this.array[index * this.itemSize + 1];
      if (this.normalized) y = denormalize(y, this.array);
      return y;
    }
  }, {
    key: "setY",
    value: function setY(index, y) {
      if (this.normalized) y = normalize(y, this.array);
      this.array[index * this.itemSize + 1] = y;
      return this;
    }
  }, {
    key: "getZ",
    value: function getZ(index) {
      var z = this.array[index * this.itemSize + 2];
      if (this.normalized) z = denormalize(z, this.array);
      return z;
    }
  }, {
    key: "setZ",
    value: function setZ(index, z) {
      if (this.normalized) z = normalize(z, this.array);
      this.array[index * this.itemSize + 2] = z;
      return this;
    }
  }, {
    key: "getW",
    value: function getW(index) {
      var w = this.array[index * this.itemSize + 3];
      if (this.normalized) w = denormalize(w, this.array);
      return w;
    }
  }, {
    key: "setW",
    value: function setW(index, w) {
      if (this.normalized) w = normalize(w, this.array);
      this.array[index * this.itemSize + 3] = w;
      return this;
    }
  }, {
    key: "setXY",
    value: function setXY(index, x, y) {
      index *= this.itemSize;
      if (this.normalized) {
        x = normalize(x, this.array);
        y = normalize(y, this.array);
      }
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      return this;
    }
  }, {
    key: "setXYZ",
    value: function setXYZ(index, x, y, z) {
      index *= this.itemSize;
      if (this.normalized) {
        x = normalize(x, this.array);
        y = normalize(y, this.array);
        z = normalize(z, this.array);
      }
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      return this;
    }
  }, {
    key: "setXYZW",
    value: function setXYZW(index, x, y, z, w) {
      index *= this.itemSize;
      if (this.normalized) {
        x = normalize(x, this.array);
        y = normalize(y, this.array);
        z = normalize(z, this.array);
        w = normalize(w, this.array);
      }
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      this.array[index + 3] = w;
      return this;
    }
  }, {
    key: "onUpload",
    value: function onUpload(callback) {
      this.onUploadCallback = callback;
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.from(this.array),
        normalized: this.normalized
      };
      if (this.name !== '') data.name = this.name;
      if (this.usage !== StaticDrawUsage) data.usage = this.usage;
      return data;
    }
  }]);
  return BufferAttribute;
}();
var Uint16BufferAttribute = /*#__PURE__*/function (_BufferAttribute) {
  _inherits(Uint16BufferAttribute, _BufferAttribute);
  var _super5 = _createSuper(Uint16BufferAttribute);
  function Uint16BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Uint16BufferAttribute);
    return _super5.call(this, new Uint16Array(array), itemSize, normalized);
  }
  return _createClass(Uint16BufferAttribute);
}(BufferAttribute);
var Uint32BufferAttribute = /*#__PURE__*/function (_BufferAttribute2) {
  _inherits(Uint32BufferAttribute, _BufferAttribute2);
  var _super6 = _createSuper(Uint32BufferAttribute);
  function Uint32BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Uint32BufferAttribute);
    return _super6.call(this, new Uint32Array(array), itemSize, normalized);
  }
  return _createClass(Uint32BufferAttribute);
}(BufferAttribute);
var Float32BufferAttribute = /*#__PURE__*/function (_BufferAttribute3) {
  _inherits(Float32BufferAttribute, _BufferAttribute3);
  var _super7 = _createSuper(Float32BufferAttribute);
  function Float32BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Float32BufferAttribute);
    return _super7.call(this, new Float32Array(array), itemSize, normalized);
  }
  return _createClass(Float32BufferAttribute);
}(BufferAttribute);
var _id$2 = 0;
var _m1 = /*@__PURE__*/new Matrix4();
var _obj = /*@__PURE__*/new Object3D();
var _offset = /*@__PURE__*/new Vector3();
var _box$2 = /*@__PURE__*/new Box3();
var _boxMorphTargets = /*@__PURE__*/new Box3();
var _vector$8 = /*@__PURE__*/new Vector3();
var BufferGeometry = /*#__PURE__*/function (_EventDispatcher4) {
  _inherits(BufferGeometry, _EventDispatcher4);
  var _super8 = _createSuper(BufferGeometry);
  function BufferGeometry() {
    var _this5;
    _classCallCheck(this, BufferGeometry);
    _this5 = _super8.call(this);
    _this5.isBufferGeometry = true;
    Object.defineProperty(_assertThisInitialized(_this5), 'id', {
      value: _id$2++
    });
    _this5.uuid = generateUUID();
    _this5.name = '';
    _this5.type = 'BufferGeometry';
    _this5.index = null;
    _this5.attributes = {};
    _this5.morphAttributes = {};
    _this5.morphTargetsRelative = false;
    _this5.groups = [];
    _this5.boundingBox = null;
    _this5.boundingSphere = null;
    _this5.drawRange = {
      start: 0,
      count: Infinity
    };
    _this5.userData = {};
    return _this5;
  }
  _createClass(BufferGeometry, [{
    key: "getIndex",
    value: function getIndex() {
      return this.index;
    }
  }, {
    key: "setIndex",
    value: function setIndex(index) {
      if (Array.isArray(index)) {
        this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
      } else {
        this.index = index;
      }
      return this;
    }
  }, {
    key: "getAttribute",
    value: function getAttribute(name) {
      return this.attributes[name];
    }
  }, {
    key: "setAttribute",
    value: function setAttribute(name, attribute) {
      this.attributes[name] = attribute;
      return this;
    }
  }, {
    key: "deleteAttribute",
    value: function deleteAttribute(name) {
      delete this.attributes[name];
      return this;
    }
  }, {
    key: "hasAttribute",
    value: function hasAttribute(name) {
      return this.attributes[name] !== undefined;
    }
  }, {
    key: "addGroup",
    value: function addGroup(start, count) {
      var materialIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this.groups.push({
        start: start,
        count: count,
        materialIndex: materialIndex
      });
    }
  }, {
    key: "clearGroups",
    value: function clearGroups() {
      this.groups = [];
    }
  }, {
    key: "setDrawRange",
    value: function setDrawRange(start, count) {
      this.drawRange.start = start;
      this.drawRange.count = count;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix) {
      var position = this.attributes.position;
      if (position !== undefined) {
        position.applyMatrix4(matrix);
        position.needsUpdate = true;
      }
      var normal = this.attributes.normal;
      if (normal !== undefined) {
        var normalMatrix = new Matrix3().getNormalMatrix(matrix);
        normal.applyNormalMatrix(normalMatrix);
        normal.needsUpdate = true;
      }
      var tangent = this.attributes.tangent;
      if (tangent !== undefined) {
        tangent.transformDirection(matrix);
        tangent.needsUpdate = true;
      }
      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }
      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }
      return this;
    }
  }, {
    key: "applyQuaternion",
    value: function applyQuaternion(q) {
      _m1.makeRotationFromQuaternion(q);
      this.applyMatrix4(_m1);
      return this;
    }
  }, {
    key: "rotateX",
    value: function rotateX(angle) {
      // rotate geometry around world x-axis

      _m1.makeRotationX(angle);
      this.applyMatrix4(_m1);
      return this;
    }
  }, {
    key: "rotateY",
    value: function rotateY(angle) {
      // rotate geometry around world y-axis

      _m1.makeRotationY(angle);
      this.applyMatrix4(_m1);
      return this;
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(angle) {
      // rotate geometry around world z-axis

      _m1.makeRotationZ(angle);
      this.applyMatrix4(_m1);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(x, y, z) {
      // translate geometry

      _m1.makeTranslation(x, y, z);
      this.applyMatrix4(_m1);
      return this;
    }
  }, {
    key: "scale",
    value: function scale(x, y, z) {
      // scale geometry

      _m1.makeScale(x, y, z);
      this.applyMatrix4(_m1);
      return this;
    }
  }, {
    key: "lookAt",
    value: function lookAt(vector) {
      _obj.lookAt(vector);
      _obj.updateMatrix();
      this.applyMatrix4(_obj.matrix);
      return this;
    }
  }, {
    key: "center",
    value: function center() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(_offset).negate();
      this.translate(_offset.x, _offset.y, _offset.z);
      return this;
    }
  }, {
    key: "setFromPoints",
    value: function setFromPoints(points) {
      var position = [];
      for (var i = 0, l = points.length; i < l; i++) {
        var point = points[i];
        position.push(point.x, point.y, point.z || 0);
      }
      this.setAttribute('position', new Float32BufferAttribute(position, 3));
      return this;
    }
  }, {
    key: "computeBoundingBox",
    value: function computeBoundingBox() {
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }
      var position = this.attributes.position;
      var morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
        this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
        return;
      }
      if (position !== undefined) {
        this.boundingBox.setFromBufferAttribute(position);

        // process morph attributes if present

        if (morphAttributesPosition) {
          for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
            var morphAttribute = morphAttributesPosition[i];
            _box$2.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$8.addVectors(this.boundingBox.min, _box$2.min);
              this.boundingBox.expandByPoint(_vector$8);
              _vector$8.addVectors(this.boundingBox.max, _box$2.max);
              this.boundingBox.expandByPoint(_vector$8);
            } else {
              this.boundingBox.expandByPoint(_box$2.min);
              this.boundingBox.expandByPoint(_box$2.max);
            }
          }
        }
      } else {
        this.boundingBox.makeEmpty();
      }
      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }, {
    key: "computeBoundingSphere",
    value: function computeBoundingSphere() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      var position = this.attributes.position;
      var morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
        this.boundingSphere.set(new Vector3(), Infinity);
        return;
      }
      if (position) {
        // first, find the center of the bounding sphere

        var center = this.boundingSphere.center;
        _box$2.setFromBufferAttribute(position);

        // process morph attributes if present

        if (morphAttributesPosition) {
          for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
            var morphAttribute = morphAttributesPosition[i];
            _boxMorphTargets.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
              _box$2.expandByPoint(_vector$8);
              _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
              _box$2.expandByPoint(_vector$8);
            } else {
              _box$2.expandByPoint(_boxMorphTargets.min);
              _box$2.expandByPoint(_boxMorphTargets.max);
            }
          }
        }
        _box$2.getCenter(center);

        // second, try to find a boundingSphere with a radius smaller than the
        // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

        var maxRadiusSq = 0;
        for (var _i7 = 0, _il = position.count; _i7 < _il; _i7++) {
          _vector$8.fromBufferAttribute(position, _i7);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
        }

        // process morph attributes if present

        if (morphAttributesPosition) {
          for (var _i8 = 0, _il2 = morphAttributesPosition.length; _i8 < _il2; _i8++) {
            var _morphAttribute = morphAttributesPosition[_i8];
            var morphTargetsRelative = this.morphTargetsRelative;
            for (var j = 0, jl = _morphAttribute.count; j < jl; j++) {
              _vector$8.fromBufferAttribute(_morphAttribute, j);
              if (morphTargetsRelative) {
                _offset.fromBufferAttribute(position, j);
                _vector$8.add(_offset);
              }
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
            }
          }
        }
        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
    }
  }, {
    key: "computeTangents",
    value: function computeTangents() {
      var index = this.index;
      var attributes = this.attributes;

      // based on http://www.terathon.com/code/tangent.html
      // (per vertex tangents)

      if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
        console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
        return;
      }
      var indices = index.array;
      var positions = attributes.position.array;
      var normals = attributes.normal.array;
      var uvs = attributes.uv.array;
      var nVertices = positions.length / 3;
      if (this.hasAttribute('tangent') === false) {
        this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));
      }
      var tangents = this.getAttribute('tangent').array;
      var tan1 = [],
        tan2 = [];
      for (var i = 0; i < nVertices; i++) {
        tan1[i] = new Vector3();
        tan2[i] = new Vector3();
      }
      var vA = new Vector3(),
        vB = new Vector3(),
        vC = new Vector3(),
        uvA = new Vector2(),
        uvB = new Vector2(),
        uvC = new Vector2(),
        sdir = new Vector3(),
        tdir = new Vector3();
      function handleTriangle(a, b, c) {
        vA.fromArray(positions, a * 3);
        vB.fromArray(positions, b * 3);
        vC.fromArray(positions, c * 3);
        uvA.fromArray(uvs, a * 2);
        uvB.fromArray(uvs, b * 2);
        uvC.fromArray(uvs, c * 2);
        vB.sub(vA);
        vC.sub(vA);
        uvB.sub(uvA);
        uvC.sub(uvA);
        var r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);

        // silently ignore degenerate uv triangles having coincident or colinear vertices

        if (!isFinite(r)) return;
        sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
        tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
        tan1[a].add(sdir);
        tan1[b].add(sdir);
        tan1[c].add(sdir);
        tan2[a].add(tdir);
        tan2[b].add(tdir);
        tan2[c].add(tdir);
      }
      var groups = this.groups;
      if (groups.length === 0) {
        groups = [{
          start: 0,
          count: indices.length
        }];
      }
      for (var _i9 = 0, il = groups.length; _i9 < il; ++_i9) {
        var group = groups[_i9];
        var start = group.start;
        var count = group.count;
        for (var j = start, jl = start + count; j < jl; j += 3) {
          handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
        }
      }
      var tmp = new Vector3(),
        tmp2 = new Vector3();
      var n = new Vector3(),
        n2 = new Vector3();
      function handleVertex(v) {
        n.fromArray(normals, v * 3);
        n2.copy(n);
        var t = tan1[v];

        // Gram-Schmidt orthogonalize

        tmp.copy(t);
        tmp.sub(n.multiplyScalar(n.dot(t))).normalize();

        // Calculate handedness

        tmp2.crossVectors(n2, t);
        var test = tmp2.dot(tan2[v]);
        var w = test < 0.0 ? -1.0 : 1.0;
        tangents[v * 4] = tmp.x;
        tangents[v * 4 + 1] = tmp.y;
        tangents[v * 4 + 2] = tmp.z;
        tangents[v * 4 + 3] = w;
      }
      for (var _i10 = 0, _il3 = groups.length; _i10 < _il3; ++_i10) {
        var _group = groups[_i10];
        var _start = _group.start;
        var _count = _group.count;
        for (var _j = _start, _jl = _start + _count; _j < _jl; _j += 3) {
          handleVertex(indices[_j + 0]);
          handleVertex(indices[_j + 1]);
          handleVertex(indices[_j + 2]);
        }
      }
    }
  }, {
    key: "computeVertexNormals",
    value: function computeVertexNormals() {
      var index = this.index;
      var positionAttribute = this.getAttribute('position');
      if (positionAttribute !== undefined) {
        var normalAttribute = this.getAttribute('normal');
        if (normalAttribute === undefined) {
          normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
          this.setAttribute('normal', normalAttribute);
        } else {
          // reset existing normals to zero

          for (var i = 0, il = normalAttribute.count; i < il; i++) {
            normalAttribute.setXYZ(i, 0, 0, 0);
          }
        }
        var pA = new Vector3(),
          pB = new Vector3(),
          pC = new Vector3();
        var nA = new Vector3(),
          nB = new Vector3(),
          nC = new Vector3();
        var cb = new Vector3(),
          ab = new Vector3();

        // indexed elements

        if (index) {
          for (var _i11 = 0, _il4 = index.count; _i11 < _il4; _i11 += 3) {
            var vA = index.getX(_i11 + 0);
            var vB = index.getX(_i11 + 1);
            var vC = index.getX(_i11 + 2);
            pA.fromBufferAttribute(positionAttribute, vA);
            pB.fromBufferAttribute(positionAttribute, vB);
            pC.fromBufferAttribute(positionAttribute, vC);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            nA.fromBufferAttribute(normalAttribute, vA);
            nB.fromBufferAttribute(normalAttribute, vB);
            nC.fromBufferAttribute(normalAttribute, vC);
            nA.add(cb);
            nB.add(cb);
            nC.add(cb);
            normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
            normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
            normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
          }
        } else {
          // non-indexed elements (unconnected triangle soup)

          for (var _i12 = 0, _il5 = positionAttribute.count; _i12 < _il5; _i12 += 3) {
            pA.fromBufferAttribute(positionAttribute, _i12 + 0);
            pB.fromBufferAttribute(positionAttribute, _i12 + 1);
            pC.fromBufferAttribute(positionAttribute, _i12 + 2);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normalAttribute.setXYZ(_i12 + 0, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(_i12 + 1, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(_i12 + 2, cb.x, cb.y, cb.z);
          }
        }
        this.normalizeNormals();
        normalAttribute.needsUpdate = true;
      }
    }
  }, {
    key: "normalizeNormals",
    value: function normalizeNormals() {
      var normals = this.attributes.normal;
      for (var i = 0, il = normals.count; i < il; i++) {
        _vector$8.fromBufferAttribute(normals, i);
        _vector$8.normalize();
        normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
      }
    }
  }, {
    key: "toNonIndexed",
    value: function toNonIndexed() {
      function convertBufferAttribute(attribute, indices) {
        var array = attribute.array;
        var itemSize = attribute.itemSize;
        var normalized = attribute.normalized;
        var array2 = new array.constructor(indices.length * itemSize);
        var index = 0,
          index2 = 0;
        for (var i = 0, l = indices.length; i < l; i++) {
          if (attribute.isInterleavedBufferAttribute) {
            index = indices[i] * attribute.data.stride + attribute.offset;
          } else {
            index = indices[i] * itemSize;
          }
          for (var j = 0; j < itemSize; j++) {
            array2[index2++] = array[index++];
          }
        }
        return new BufferAttribute(array2, itemSize, normalized);
      }

      //

      if (this.index === null) {
        console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
        return this;
      }
      var geometry2 = new BufferGeometry();
      var indices = this.index.array;
      var attributes = this.attributes;

      // attributes

      for (var name in attributes) {
        var attribute = attributes[name];
        var newAttribute = convertBufferAttribute(attribute, indices);
        geometry2.setAttribute(name, newAttribute);
      }

      // morph attributes

      var morphAttributes = this.morphAttributes;
      for (var _name in morphAttributes) {
        var morphArray = [];
        var morphAttribute = morphAttributes[_name]; // morphAttribute: array of Float32BufferAttributes

        for (var i = 0, il = morphAttribute.length; i < il; i++) {
          var _attribute = morphAttribute[i];
          var _newAttribute = convertBufferAttribute(_attribute, indices);
          morphArray.push(_newAttribute);
        }
        geometry2.morphAttributes[_name] = morphArray;
      }
      geometry2.morphTargetsRelative = this.morphTargetsRelative;

      // groups

      var groups = this.groups;
      for (var _i13 = 0, l = groups.length; _i13 < l; _i13++) {
        var group = groups[_i13];
        geometry2.addGroup(group.start, group.count, group.materialIndex);
      }
      return geometry2;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = {
        metadata: {
          version: 4.6,
          type: 'BufferGeometry',
          generator: 'BufferGeometry.toJSON'
        }
      };

      // standard BufferGeometry serialization

      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== '') data.name = this.name;
      if (Object.keys(this.userData).length > 0) data.userData = this.userData;
      if (this.parameters !== undefined) {
        var parameters = this.parameters;
        for (var key in parameters) {
          if (parameters[key] !== undefined) data[key] = parameters[key];
        }
        return data;
      }

      // for simplicity the code assumes attributes are not shared across geometries, see #15811

      data.data = {
        attributes: {}
      };
      var index = this.index;
      if (index !== null) {
        data.data.index = {
          type: index.array.constructor.name,
          array: Array.prototype.slice.call(index.array)
        };
      }
      var attributes = this.attributes;
      for (var _key in attributes) {
        var attribute = attributes[_key];
        data.data.attributes[_key] = attribute.toJSON(data.data);
      }
      var morphAttributes = {};
      var hasMorphAttributes = false;
      for (var _key2 in this.morphAttributes) {
        var attributeArray = this.morphAttributes[_key2];
        var array = [];
        for (var i = 0, il = attributeArray.length; i < il; i++) {
          var _attribute2 = attributeArray[i];
          array.push(_attribute2.toJSON(data.data));
        }
        if (array.length > 0) {
          morphAttributes[_key2] = array;
          hasMorphAttributes = true;
        }
      }
      if (hasMorphAttributes) {
        data.data.morphAttributes = morphAttributes;
        data.data.morphTargetsRelative = this.morphTargetsRelative;
      }
      var groups = this.groups;
      if (groups.length > 0) {
        data.data.groups = JSON.parse(JSON.stringify(groups));
      }
      var boundingSphere = this.boundingSphere;
      if (boundingSphere !== null) {
        data.data.boundingSphere = {
          center: boundingSphere.center.toArray(),
          radius: boundingSphere.radius
        };
      }
      return data;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      // reset

      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;

      // used for storing cloned, shared data

      var data = {};

      // name

      this.name = source.name;

      // index

      var index = source.index;
      if (index !== null) {
        this.setIndex(index.clone(data));
      }

      // attributes

      var attributes = source.attributes;
      for (var name in attributes) {
        var attribute = attributes[name];
        this.setAttribute(name, attribute.clone(data));
      }

      // morph attributes

      var morphAttributes = source.morphAttributes;
      for (var _name2 in morphAttributes) {
        var array = [];
        var morphAttribute = morphAttributes[_name2]; // morphAttribute: array of Float32BufferAttributes

        for (var i = 0, l = morphAttribute.length; i < l; i++) {
          array.push(morphAttribute[i].clone(data));
        }
        this.morphAttributes[_name2] = array;
      }
      this.morphTargetsRelative = source.morphTargetsRelative;

      // groups

      var groups = source.groups;
      for (var _i14 = 0, _l4 = groups.length; _i14 < _l4; _i14++) {
        var group = groups[_i14];
        this.addGroup(group.start, group.count, group.materialIndex);
      }

      // bounding box

      var boundingBox = source.boundingBox;
      if (boundingBox !== null) {
        this.boundingBox = boundingBox.clone();
      }

      // bounding sphere

      var boundingSphere = source.boundingSphere;
      if (boundingSphere !== null) {
        this.boundingSphere = boundingSphere.clone();
      }

      // draw range

      this.drawRange.start = source.drawRange.start;
      this.drawRange.count = source.drawRange.count;

      // user data

      this.userData = source.userData;
      return this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
    }
  }]);
  return BufferGeometry;
}(EventDispatcher);
var _inverseMatrix$3 = /*@__PURE__*/new Matrix4();
var _ray$3 = /*@__PURE__*/new Ray();
var _sphere$6 = /*@__PURE__*/new Sphere();
var _sphereHitAt = /*@__PURE__*/new Vector3();
var _vA$1 = /*@__PURE__*/new Vector3();
var _vB$1 = /*@__PURE__*/new Vector3();
var _vC$1 = /*@__PURE__*/new Vector3();
var _tempA = /*@__PURE__*/new Vector3();
var _morphA = /*@__PURE__*/new Vector3();
var _uvA$1 = /*@__PURE__*/new Vector2();
var _uvB$1 = /*@__PURE__*/new Vector2();
var _uvC$1 = /*@__PURE__*/new Vector2();
var _normalA = /*@__PURE__*/new Vector3();
var _normalB = /*@__PURE__*/new Vector3();
var _normalC = /*@__PURE__*/new Vector3();
var _intersectionPoint = /*@__PURE__*/new Vector3();
var _intersectionPointWorld = /*@__PURE__*/new Vector3();
var Mesh = /*#__PURE__*/function (_Object3D) {
  _inherits(Mesh, _Object3D);
  var _super9 = _createSuper(Mesh);
  function Mesh() {
    var _this6;
    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();
    var material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new MeshBasicMaterial();
    _classCallCheck(this, Mesh);
    _this6 = _super9.call(this);
    _this6.isMesh = true;
    _this6.type = 'Mesh';
    _this6.geometry = geometry;
    _this6.material = material;
    _this6.updateMorphTargets();
    return _this6;
  }
  _createClass(Mesh, [{
    key: "copy",
    value: function copy(source, recursive) {
      _get(_getPrototypeOf(Mesh.prototype), "copy", this).call(this, source, recursive);
      if (source.morphTargetInfluences !== undefined) {
        this.morphTargetInfluences = source.morphTargetInfluences.slice();
      }
      if (source.morphTargetDictionary !== undefined) {
        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
      }
      this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
      this.geometry = source.geometry;
      return this;
    }
  }, {
    key: "updateMorphTargets",
    value: function updateMorphTargets() {
      var geometry = this.geometry;
      var morphAttributes = geometry.morphAttributes;
      var keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        var morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
            var name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    }
  }, {
    key: "getVertexPosition",
    value: function getVertexPosition(index, target) {
      var geometry = this.geometry;
      var position = geometry.attributes.position;
      var morphPosition = geometry.morphAttributes.position;
      var morphTargetsRelative = geometry.morphTargetsRelative;
      target.fromBufferAttribute(position, index);
      var morphInfluences = this.morphTargetInfluences;
      if (morphPosition && morphInfluences) {
        _morphA.set(0, 0, 0);
        for (var i = 0, il = morphPosition.length; i < il; i++) {
          var influence = morphInfluences[i];
          var morphAttribute = morphPosition[i];
          if (influence === 0) continue;
          _tempA.fromBufferAttribute(morphAttribute, index);
          if (morphTargetsRelative) {
            _morphA.addScaledVector(_tempA, influence);
          } else {
            _morphA.addScaledVector(_tempA.sub(target), influence);
          }
        }
        target.add(_morphA);
      }
      return target;
    }
  }, {
    key: "raycast",
    value: function raycast(raycaster, intersects) {
      var geometry = this.geometry;
      var material = this.material;
      var matrixWorld = this.matrixWorld;
      if (material === undefined) return;

      // test with bounding sphere in world space

      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere$6.copy(geometry.boundingSphere);
      _sphere$6.applyMatrix4(matrixWorld);

      // check distance from ray origin to bounding sphere

      _ray$3.copy(raycaster.ray).recast(raycaster.near);
      if (_sphere$6.containsPoint(_ray$3.origin) === false) {
        if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;
        if (_ray$3.origin.distanceToSquared(_sphereHitAt) > Math.pow(raycaster.far - raycaster.near, 2)) return;
      }

      // convert ray to local space of mesh

      _inverseMatrix$3.copy(matrixWorld).invert();
      _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);

      // test with bounding box in local space

      if (geometry.boundingBox !== null) {
        if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;
      }

      // test for intersections with geometry

      this._computeIntersections(raycaster, intersects, _ray$3);
    }
  }, {
    key: "_computeIntersections",
    value: function _computeIntersections(raycaster, intersects, rayLocalSpace) {
      var intersection;
      var geometry = this.geometry;
      var material = this.material;
      var index = geometry.index;
      var position = geometry.attributes.position;
      var uv = geometry.attributes.uv;
      var uv1 = geometry.attributes.uv1;
      var normal = geometry.attributes.normal;
      var groups = geometry.groups;
      var drawRange = geometry.drawRange;
      if (index !== null) {
        // indexed buffer geometry

        if (Array.isArray(material)) {
          for (var i = 0, il = groups.length; i < il; i++) {
            var group = groups[i];
            var groupMaterial = material[group.materialIndex];
            var start = Math.max(group.start, drawRange.start);
            var end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (var j = start, jl = end; j < jl; j += 3) {
              var a = index.getX(j);
              var b = index.getX(j + 1);
              var c = index.getX(j + 2);
              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          var _start2 = Math.max(0, drawRange.start);
          var _end = Math.min(index.count, drawRange.start + drawRange.count);
          for (var _i15 = _start2, _il6 = _end; _i15 < _il6; _i15 += 3) {
            var _a = index.getX(_i15);
            var _b = index.getX(_i15 + 1);
            var _c = index.getX(_i15 + 2);
            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, _a, _b, _c);
            if (intersection) {
              intersection.faceIndex = Math.floor(_i15 / 3); // triangle number in indexed buffer semantics
              intersects.push(intersection);
            }
          }
        }
      } else if (position !== undefined) {
        // non-indexed buffer geometry

        if (Array.isArray(material)) {
          for (var _i16 = 0, _il7 = groups.length; _i16 < _il7; _i16++) {
            var _group2 = groups[_i16];
            var _groupMaterial = material[_group2.materialIndex];
            var _start3 = Math.max(_group2.start, drawRange.start);
            var _end2 = Math.min(position.count, Math.min(_group2.start + _group2.count, drawRange.start + drawRange.count));
            for (var _j2 = _start3, _jl2 = _end2; _j2 < _jl2; _j2 += 3) {
              var _a2 = _j2;
              var _b2 = _j2 + 1;
              var _c2 = _j2 + 2;
              intersection = checkGeometryIntersection(this, _groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, _a2, _b2, _c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(_j2 / 3); // triangle number in non-indexed buffer semantics
                intersection.face.materialIndex = _group2.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          var _start4 = Math.max(0, drawRange.start);
          var _end3 = Math.min(position.count, drawRange.start + drawRange.count);
          for (var _i17 = _start4, _il8 = _end3; _i17 < _il8; _i17 += 3) {
            var _a3 = _i17;
            var _b3 = _i17 + 1;
            var _c3 = _i17 + 2;
            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, _a3, _b3, _c3);
            if (intersection) {
              intersection.faceIndex = Math.floor(_i17 / 3); // triangle number in non-indexed buffer semantics
              intersects.push(intersection);
            }
          }
        }
      }
    }
  }]);
  return Mesh;
}(Object3D);
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
  var intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);
  }
  if (intersect === null) return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  var distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far) return null;
  return {
    distance: distance,
    point: _intersectionPointWorld.clone(),
    object: object
  };
}
function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {
  object.getVertexPosition(a, _vA$1);
  object.getVertexPosition(b, _vB$1);
  object.getVertexPosition(c, _vC$1);
  var intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA$1.fromBufferAttribute(uv, a);
      _uvB$1.fromBufferAttribute(uv, b);
      _uvC$1.fromBufferAttribute(uv, c);
      intersection.uv = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    if (uv1) {
      _uvA$1.fromBufferAttribute(uv1, a);
      _uvB$1.fromBufferAttribute(uv1, b);
      _uvC$1.fromBufferAttribute(uv1, c);
      intersection.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
      intersection.uv2 = intersection.uv1; // @deprecated, r152
    }

    if (normal) {
      _normalA.fromBufferAttribute(normal, a);
      _normalB.fromBufferAttribute(normal, b);
      _normalC.fromBufferAttribute(normal, c);
      intersection.normal = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector3());
      if (intersection.normal.dot(ray.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    var face = {
      a: a,
      b: b,
      c: c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
  }
  return intersection;
}

/**
 * Uniform Utilities
 */

function cloneUniforms(src) {
  var dst = {};
  for (var u in src) {
    dst[u] = {};
    for (var p in src[u]) {
      var property = src[u][p];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        if (property.isRenderTargetTexture) {
          console.warn('UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().');
          dst[u][p] = null;
        } else {
          dst[u][p] = property.clone();
        }
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }
  return dst;
}
function cloneUniformsGroups(src) {
  var dst = [];
  for (var u = 0; u < src.length; u++) {
    dst.push(src[u].clone());
  }
  return dst;
}
var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
var ShaderMaterial = /*#__PURE__*/function (_Material2) {
  _inherits(ShaderMaterial, _Material2);
  var _super10 = _createSuper(ShaderMaterial);
  function ShaderMaterial(parameters) {
    var _this7;
    _classCallCheck(this, ShaderMaterial);
    _this7 = _super10.call(this);
    _this7.isShaderMaterial = true;
    _this7.type = 'ShaderMaterial';
    _this7.defines = {};
    _this7.uniforms = {};
    _this7.uniformsGroups = [];
    _this7.vertexShader = default_vertex;
    _this7.fragmentShader = default_fragment;
    _this7.linewidth = 1;
    _this7.wireframe = false;
    _this7.wireframeLinewidth = 1;
    _this7.fog = false; // set to use scene fog
    _this7.lights = false; // set to use scene lights
    _this7.clipping = false; // set to use user-defined clipping planes

    _this7.forceSinglePass = true;
    _this7.extensions = {
      derivatives: false,
      // set to use derivatives
      fragDepth: false,
      // set to use fragment depth values
      drawBuffers: false,
      // set to use draw buffers
      shaderTextureLOD: false,
      // set to use shader texture LOD
      clipCullDistance: false,
      // set to use vertex shader clipping
      multiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID
    };

    // When rendered geometry doesn't include these attributes but the material does,
    // use these default values in WebGL. This avoids errors when buffer data is missing.
    _this7.defaultAttributeValues = {
      'color': [1, 1, 1],
      'uv': [0, 0],
      'uv1': [0, 0]
    };
    _this7.index0AttributeName = undefined;
    _this7.uniformsNeedUpdate = false;
    _this7.glslVersion = null;
    if (parameters !== undefined) {
      _this7.setValues(parameters);
    }
    return _this7;
  }
  _createClass(ShaderMaterial, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(ShaderMaterial.prototype), "copy", this).call(this, source);
      this.fragmentShader = source.fragmentShader;
      this.vertexShader = source.vertexShader;
      this.uniforms = cloneUniforms(source.uniforms);
      this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
      this.defines = Object.assign({}, source.defines);
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.fog = source.fog;
      this.lights = source.lights;
      this.clipping = source.clipping;
      this.extensions = Object.assign({}, source.extensions);
      this.glslVersion = source.glslVersion;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _get(_getPrototypeOf(ShaderMaterial.prototype), "toJSON", this).call(this, meta);
      data.glslVersion = this.glslVersion;
      data.uniforms = {};
      for (var name in this.uniforms) {
        var uniform = this.uniforms[name];
        var _value2 = uniform.value;
        if (_value2 && _value2.isTexture) {
          data.uniforms[name] = {
            type: 't',
            value: _value2.toJSON(meta).uuid
          };
        } else if (_value2 && _value2.isColor) {
          data.uniforms[name] = {
            type: 'c',
            value: _value2.getHex()
          };
        } else if (_value2 && _value2.isVector2) {
          data.uniforms[name] = {
            type: 'v2',
            value: _value2.toArray()
          };
        } else if (_value2 && _value2.isVector3) {
          data.uniforms[name] = {
            type: 'v3',
            value: _value2.toArray()
          };
        } else if (_value2 && _value2.isVector4) {
          data.uniforms[name] = {
            type: 'v4',
            value: _value2.toArray()
          };
        } else if (_value2 && _value2.isMatrix3) {
          data.uniforms[name] = {
            type: 'm3',
            value: _value2.toArray()
          };
        } else if (_value2 && _value2.isMatrix4) {
          data.uniforms[name] = {
            type: 'm4',
            value: _value2.toArray()
          };
        } else {
          data.uniforms[name] = {
            value: _value2
          };

          // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
        }
      }

      if (Object.keys(this.defines).length > 0) data.defines = this.defines;
      data.vertexShader = this.vertexShader;
      data.fragmentShader = this.fragmentShader;
      data.lights = this.lights;
      data.clipping = this.clipping;
      var extensions = {};
      for (var key in this.extensions) {
        if (this.extensions[key] === true) extensions[key] = true;
      }
      if (Object.keys(extensions).length > 0) data.extensions = extensions;
      return data;
    }
  }]);
  return ShaderMaterial;
}(Material);
var Camera = /*#__PURE__*/function (_Object3D2) {
  _inherits(Camera, _Object3D2);
  var _super11 = _createSuper(Camera);
  function Camera() {
    var _this8;
    _classCallCheck(this, Camera);
    _this8 = _super11.call(this);
    _this8.isCamera = true;
    _this8.type = 'Camera';
    _this8.matrixWorldInverse = new Matrix4();
    _this8.projectionMatrix = new Matrix4();
    _this8.projectionMatrixInverse = new Matrix4();
    _this8.coordinateSystem = WebGLCoordinateSystem;
    return _this8;
  }
  _createClass(Camera, [{
    key: "copy",
    value: function copy(source, recursive) {
      _get(_getPrototypeOf(Camera.prototype), "copy", this).call(this, source, recursive);
      this.matrixWorldInverse.copy(source.matrixWorldInverse);
      this.projectionMatrix.copy(source.projectionMatrix);
      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
      this.coordinateSystem = source.coordinateSystem;
      return this;
    }
  }, {
    key: "getWorldDirection",
    value: function getWorldDirection(target) {
      return _get(_getPrototypeOf(Camera.prototype), "getWorldDirection", this).call(this, target).negate();
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(force) {
      _get(_getPrototypeOf(Camera.prototype), "updateMatrixWorld", this).call(this, force);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
  }, {
    key: "updateWorldMatrix",
    value: function updateWorldMatrix(updateParents, updateChildren) {
      _get(_getPrototypeOf(Camera.prototype), "updateWorldMatrix", this).call(this, updateParents, updateChildren);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
  return Camera;
}(Object3D);
var _v3$1 = /*@__PURE__*/new Vector3();
var _minTarget = /*@__PURE__*/new Vector2();
var _maxTarget = /*@__PURE__*/new Vector2();
var PerspectiveCamera = /*#__PURE__*/function (_Camera) {
  _inherits(PerspectiveCamera, _Camera);
  var _super12 = _createSuper(PerspectiveCamera);
  function PerspectiveCamera() {
    var _this9;
    var fov = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
    var aspect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;
    var far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2000;
    _classCallCheck(this, PerspectiveCamera);
    _this9 = _super12.call(this);
    _this9.isPerspectiveCamera = true;
    _this9.type = 'PerspectiveCamera';
    _this9.fov = fov;
    _this9.zoom = 1;
    _this9.near = near;
    _this9.far = far;
    _this9.focus = 10;
    _this9.aspect = aspect;
    _this9.view = null;
    _this9.filmGauge = 35; // width of the film (default in millimeters)
    _this9.filmOffset = 0; // horizontal film offset (same unit as gauge)

    _this9.updateProjectionMatrix();
    return _this9;
  }
  _createClass(PerspectiveCamera, [{
    key: "copy",
    value: function copy(source, recursive) {
      _get(_getPrototypeOf(PerspectiveCamera.prototype), "copy", this).call(this, source, recursive);
      this.fov = source.fov;
      this.zoom = source.zoom;
      this.near = source.near;
      this.far = source.far;
      this.focus = source.focus;
      this.aspect = source.aspect;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      this.filmGauge = source.filmGauge;
      this.filmOffset = source.filmOffset;
      return this;
    }

    /**
     * Sets the FOV by focal length in respect to the current .filmGauge.
     *
     * The default film gauge is 35, so that the focal length can be specified for
     * a 35mm (full frame) camera.
     *
     * Values for focal length and film gauge must have the same unit.
     */
  }, {
    key: "setFocalLength",
    value: function setFocalLength(focalLength) {
      /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
      var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
      this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
      this.updateProjectionMatrix();
    }

    /**
     * Calculates the focal length from the current .fov and .filmGauge.
     */
  }, {
    key: "getFocalLength",
    value: function getFocalLength() {
      var vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
      return 0.5 * this.getFilmHeight() / vExtentSlope;
    }
  }, {
    key: "getEffectiveFOV",
    value: function getEffectiveFOV() {
      return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
    }
  }, {
    key: "getFilmWidth",
    value: function getFilmWidth() {
      // film not completely covered in portrait format (aspect < 1)
      return this.filmGauge * Math.min(this.aspect, 1);
    }
  }, {
    key: "getFilmHeight",
    value: function getFilmHeight() {
      // film not completely covered in landscape format (aspect > 1)
      return this.filmGauge / Math.max(this.aspect, 1);
    }

    /**
     * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
     * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
     */
  }, {
    key: "getViewBounds",
    value: function getViewBounds(distance, minTarget, maxTarget) {
      _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);
      minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
      _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);
      maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
    }

    /**
     * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
     * Copies the result into the target Vector2, where x is width and y is height.
     */
  }, {
    key: "getViewSize",
    value: function getViewSize(distance, target) {
      this.getViewBounds(distance, _minTarget, _maxTarget);
      return target.subVectors(_maxTarget, _minTarget);
    }

    /**
     * Sets an offset in a larger frustum. This is useful for multi-window or
     * multi-monitor/multi-machine setups.
     *
     * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
     * the monitors are in grid like this
     *
     *   +---+---+---+
     *   | A | B | C |
     *   +---+---+---+
     *   | D | E | F |
     *   +---+---+---+
     *
     * then for each monitor you would call it like this
     *
     *   const w = 1920;
     *   const h = 1080;
     *   const fullWidth = w * 3;
     *   const fullHeight = h * 2;
     *
     *   --A--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
     *   --B--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
     *   --C--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
     *   --D--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
     *   --E--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
     *   --F--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
     *
     *   Note there is no reason monitors have to be the same size or in a grid.
     */
  }, {
    key: "setViewOffset",
    value: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
      this.aspect = fullWidth / fullHeight;
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width;
      this.view.height = height;
      this.updateProjectionMatrix();
    }
  }, {
    key: "clearViewOffset",
    value: function clearViewOffset() {
      if (this.view !== null) {
        this.view.enabled = false;
      }
      this.updateProjectionMatrix();
    }
  }, {
    key: "updateProjectionMatrix",
    value: function updateProjectionMatrix() {
      var near = this.near;
      var top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
      var height = 2 * top;
      var width = this.aspect * height;
      var left = -0.5 * width;
      var view = this.view;
      if (this.view !== null && this.view.enabled) {
        var fullWidth = view.fullWidth,
          fullHeight = view.fullHeight;
        left += view.offsetX * width / fullWidth;
        top -= view.offsetY * height / fullHeight;
        width *= view.width / fullWidth;
        height *= view.height / fullHeight;
      }
      var skew = this.filmOffset;
      if (skew !== 0) left += near * skew / this.getFilmWidth();
      this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _get(_getPrototypeOf(PerspectiveCamera.prototype), "toJSON", this).call(this, meta);
      data.object.fov = this.fov;
      data.object.zoom = this.zoom;
      data.object.near = this.near;
      data.object.far = this.far;
      data.object.focus = this.focus;
      data.object.aspect = this.aspect;
      if (this.view !== null) data.object.view = Object.assign({}, this.view);
      data.object.filmGauge = this.filmGauge;
      data.object.filmOffset = this.filmOffset;
      return data;
    }
  }]);
  return PerspectiveCamera;
}(Camera);
var _vector1 = /*@__PURE__*/new Vector3();
var _vector2 = /*@__PURE__*/new Vector3();
var _normalMatrix = /*@__PURE__*/new Matrix3();
var Plane = /*#__PURE__*/function () {
  function Plane() {
    var normal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(1, 0, 0);
    var constant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    _classCallCheck(this, Plane);
    this.isPlane = true;

    // normal is assumed to be normalized

    this.normal = normal;
    this.constant = constant;
  }
  _createClass(Plane, [{
    key: "set",
    value: function set(normal, constant) {
      this.normal.copy(normal);
      this.constant = constant;
      return this;
    }
  }, {
    key: "setComponents",
    value: function setComponents(x, y, z, w) {
      this.normal.set(x, y, z);
      this.constant = w;
      return this;
    }
  }, {
    key: "setFromNormalAndCoplanarPoint",
    value: function setFromNormalAndCoplanarPoint(normal, point) {
      this.normal.copy(normal);
      this.constant = -point.dot(this.normal);
      return this;
    }
  }, {
    key: "setFromCoplanarPoints",
    value: function setFromCoplanarPoints(a, b, c) {
      var normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();

      // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

      this.setFromNormalAndCoplanarPoint(normal, a);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(plane) {
      this.normal.copy(plane.normal);
      this.constant = plane.constant;
      return this;
    }
  }, {
    key: "normalize",
    value: function normalize() {
      // Note: will lead to a divide by zero if the plane is invalid.

      var inverseNormalLength = 1.0 / this.normal.length();
      this.normal.multiplyScalar(inverseNormalLength);
      this.constant *= inverseNormalLength;
      return this;
    }
  }, {
    key: "negate",
    value: function negate() {
      this.constant *= -1;
      this.normal.negate();
      return this;
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point) {
      return this.normal.dot(point) + this.constant;
    }
  }, {
    key: "distanceToSphere",
    value: function distanceToSphere(sphere) {
      return this.distanceToPoint(sphere.center) - sphere.radius;
    }
  }, {
    key: "projectPoint",
    value: function projectPoint(point, target) {
      return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
    }
  }, {
    key: "intersectLine",
    value: function intersectLine(line, target) {
      var direction = line.delta(_vector1);
      var denominator = this.normal.dot(direction);
      if (denominator === 0) {
        // line is coplanar, return origin
        if (this.distanceToPoint(line.start) === 0) {
          return target.copy(line.start);
        }

        // Unsure if this is the correct method to handle this case.
        return null;
      }
      var t = -(line.start.dot(this.normal) + this.constant) / denominator;
      if (t < 0 || t > 1) {
        return null;
      }
      return target.copy(line.start).addScaledVector(direction, t);
    }
  }, {
    key: "intersectsLine",
    value: function intersectsLine(line) {
      // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

      var startSign = this.distanceToPoint(line.start);
      var endSign = this.distanceToPoint(line.end);
      return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      return box.intersectsPlane(this);
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(sphere) {
      return sphere.intersectsPlane(this);
    }
  }, {
    key: "coplanarPoint",
    value: function coplanarPoint(target) {
      return target.copy(this.normal).multiplyScalar(-this.constant);
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix, optionalNormalMatrix) {
      var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
      var referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
      var normal = this.normal.applyMatrix3(normalMatrix).normalize();
      this.constant = -referencePoint.dot(normal);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(offset) {
      this.constant -= offset.dot(this.normal);
      return this;
    }
  }, {
    key: "equals",
    value: function equals(plane) {
      return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
  return Plane;
}();
var _sphere$5 = /*@__PURE__*/new Sphere();
var _vector$7 = /*@__PURE__*/new Vector3();
var Frustum = /*#__PURE__*/function () {
  function Frustum() {
    var p0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Plane();
    var p1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Plane();
    var p2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Plane();
    var p3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Plane();
    var p4 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new Plane();
    var p5 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Plane();
    _classCallCheck(this, Frustum);
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  _createClass(Frustum, [{
    key: "set",
    value: function set(p0, p1, p2, p3, p4, p5) {
      var planes = this.planes;
      planes[0].copy(p0);
      planes[1].copy(p1);
      planes[2].copy(p2);
      planes[3].copy(p3);
      planes[4].copy(p4);
      planes[5].copy(p5);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(frustum) {
      var planes = this.planes;
      for (var i = 0; i < 6; i++) {
        planes[i].copy(frustum.planes[i]);
      }
      return this;
    }
  }, {
    key: "setFromProjectionMatrix",
    value: function setFromProjectionMatrix(m) {
      var coordinateSystem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : WebGLCoordinateSystem;
      var planes = this.planes;
      var me = m.elements;
      var me0 = me[0],
        me1 = me[1],
        me2 = me[2],
        me3 = me[3];
      var me4 = me[4],
        me5 = me[5],
        me6 = me[6],
        me7 = me[7];
      var me8 = me[8],
        me9 = me[9],
        me10 = me[10],
        me11 = me[11];
      var me12 = me[12],
        me13 = me[13],
        me14 = me[14],
        me15 = me[15];
      planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
      planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
      planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
      planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
      planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
      if (coordinateSystem === WebGLCoordinateSystem) {
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        planes[5].setComponents(me2, me6, me10, me14).normalize();
      } else {
        throw new Error('THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem);
      }
      return this;
    }
  }, {
    key: "intersectsObject",
    value: function intersectsObject(object) {
      if (object.boundingSphere !== undefined) {
        if (object.boundingSphere === null) object.computeBoundingSphere();
        _sphere$5.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
      } else {
        var geometry = object.geometry;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere$5.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
      }
      return this.intersectsSphere(_sphere$5);
    }
  }, {
    key: "intersectsSprite",
    value: function intersectsSprite(sprite) {
      _sphere$5.center.set(0, 0, 0);
      _sphere$5.radius = 0.7071067811865476;
      _sphere$5.applyMatrix4(sprite.matrixWorld);
      return this.intersectsSphere(_sphere$5);
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(sphere) {
      var planes = this.planes;
      var center = sphere.center;
      var negRadius = -sphere.radius;
      for (var i = 0; i < 6; i++) {
        var distance = planes[i].distanceToPoint(center);
        if (distance < negRadius) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      var planes = this.planes;
      for (var i = 0; i < 6; i++) {
        var plane = planes[i];

        // corner at max distance

        _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
        if (plane.distanceToPoint(_vector$7) < 0) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      var planes = this.planes;
      for (var i = 0; i < 6; i++) {
        if (planes[i].distanceToPoint(point) < 0) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);
  return Frustum;
}();
var PlaneGeometry = /*#__PURE__*/function (_BufferGeometry) {
  _inherits(PlaneGeometry, _BufferGeometry);
  var _super13 = _createSuper(PlaneGeometry);
  function PlaneGeometry() {
    var _this10;
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var widthSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var heightSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    _classCallCheck(this, PlaneGeometry);
    _this10 = _super13.call(this);
    _this10.type = 'PlaneGeometry';
    _this10.parameters = {
      width: width,
      height: height,
      widthSegments: widthSegments,
      heightSegments: heightSegments
    };
    var width_half = width / 2;
    var height_half = height / 2;
    var gridX = Math.floor(widthSegments);
    var gridY = Math.floor(heightSegments);
    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;
    var segment_width = width / gridX;
    var segment_height = height / gridY;

    //

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    for (var iy = 0; iy < gridY1; iy++) {
      var y = iy * segment_height - height_half;
      for (var ix = 0; ix < gridX1; ix++) {
        var x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (var _iy = 0; _iy < gridY; _iy++) {
      for (var _ix = 0; _ix < gridX; _ix++) {
        var a = _ix + gridX1 * _iy;
        var b = _ix + gridX1 * (_iy + 1);
        var c = _ix + 1 + gridX1 * (_iy + 1);
        var d = _ix + 1 + gridX1 * _iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    _this10.setIndex(indices);
    _this10.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    _this10.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    _this10.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    return _this10;
  }
  _createClass(PlaneGeometry, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(PlaneGeometry.prototype), "copy", this).call(this, source);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
    }
  }]);
  return PlaneGeometry;
}(BufferGeometry);
var DepthTexture = /*#__PURE__*/function (_Texture) {
  _inherits(DepthTexture, _Texture);
  var _super14 = _createSuper(DepthTexture);
  function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    var _this11;
    _classCallCheck(this, DepthTexture);
    format = format !== undefined ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
    }
    if (type === undefined && format === DepthFormat) type = UnsignedIntType;
    if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
    _this11 = _super14.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    _this11.isDepthTexture = true;
    _this11.image = {
      width: width,
      height: height
    };
    _this11.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    _this11.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    _this11.flipY = false;
    _this11.generateMipmaps = false;
    _this11.compareFunction = null;
    return _this11;
  }
  _createClass(DepthTexture, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(DepthTexture.prototype), "copy", this).call(this, source);
      this.compareFunction = source.compareFunction;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _get(_getPrototypeOf(DepthTexture.prototype), "toJSON", this).call(this, meta);
      if (this.compareFunction !== null) data.compareFunction = this.compareFunction;
      return data;
    }
  }]);
  return DepthTexture;
}(Texture);
var emptyShadowTexture = /*@__PURE__*/new DepthTexture(1, 1);
emptyShadowTexture.compareFunction = LessEqualCompare;
var Group = /*#__PURE__*/function (_Object3D3) {
  _inherits(Group, _Object3D3);
  var _super15 = _createSuper(Group);
  function Group() {
    var _this12;
    _classCallCheck(this, Group);
    _this12 = _super15.call(this);
    _this12.isGroup = true;
    _this12.type = 'Group';
    return _this12;
  }
  return _createClass(Group);
}(Object3D);
var InterleavedBuffer = /*#__PURE__*/function () {
  function InterleavedBuffer(array, stride) {
    _classCallCheck(this, InterleavedBuffer);
    this.isInterleavedBuffer = true;
    this.array = array;
    this.stride = stride;
    this.count = array !== undefined ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this._updateRange = {
      offset: 0,
      count: -1
    };
    this.updateRanges = [];
    this.version = 0;
    this.uuid = generateUUID();
  }
  _createClass(InterleavedBuffer, [{
    key: "onUploadCallback",
    value: function onUploadCallback() {}
  }, {
    key: "needsUpdate",
    set: function set(value) {
      if (value === true) this.version++;
    }
  }, {
    key: "updateRange",
    get: function get() {
      warnOnce('THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.'); // @deprecated, r159
      return this._updateRange;
    }
  }, {
    key: "setUsage",
    value: function setUsage(value) {
      this.usage = value;
      return this;
    }
  }, {
    key: "addUpdateRange",
    value: function addUpdateRange(start, count) {
      this.updateRanges.push({
        start: start,
        count: count
      });
    }
  }, {
    key: "clearUpdateRanges",
    value: function clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.array = new source.array.constructor(source.array);
      this.count = source.count;
      this.stride = source.stride;
      this.usage = source.usage;
      return this;
    }
  }, {
    key: "copyAt",
    value: function copyAt(index1, attribute, index2) {
      index1 *= this.stride;
      index2 *= attribute.stride;
      for (var i = 0, l = this.stride; i < l; i++) {
        this.array[index1 + i] = attribute.array[index2 + i];
      }
      return this;
    }
  }, {
    key: "set",
    value: function set(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.array.set(value, offset);
      return this;
    }
  }, {
    key: "clone",
    value: function clone(data) {
      if (data.arrayBuffers === undefined) {
        data.arrayBuffers = {};
      }
      if (this.array.buffer._uuid === undefined) {
        this.array.buffer._uuid = generateUUID();
      }
      if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
        data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
      }
      var array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
      var ib = new this.constructor(array, this.stride);
      ib.setUsage(this.usage);
      return ib;
    }
  }, {
    key: "onUpload",
    value: function onUpload(callback) {
      this.onUploadCallback = callback;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(data) {
      if (data.arrayBuffers === undefined) {
        data.arrayBuffers = {};
      }

      // generate UUID for array buffer if necessary

      if (this.array.buffer._uuid === undefined) {
        this.array.buffer._uuid = generateUUID();
      }
      if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
        data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
      }

      //

      return {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride
      };
    }
  }]);
  return InterleavedBuffer;
}();
var _vector$6 = /*@__PURE__*/new Vector3();
var InterleavedBufferAttribute = /*#__PURE__*/function () {
  function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset) {
    var normalized = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    _classCallCheck(this, InterleavedBufferAttribute);
    this.isInterleavedBufferAttribute = true;
    this.name = '';
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized;
  }
  _createClass(InterleavedBufferAttribute, [{
    key: "count",
    get: function get() {
      return this.data.count;
    }
  }, {
    key: "array",
    get: function get() {
      return this.data.array;
    }
  }, {
    key: "needsUpdate",
    set: function set(value) {
      this.data.needsUpdate = value;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(m) {
      for (var i = 0, l = this.data.count; i < l; i++) {
        _vector$6.fromBufferAttribute(this, i);
        _vector$6.applyMatrix4(m);
        this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
      }
      return this;
    }
  }, {
    key: "applyNormalMatrix",
    value: function applyNormalMatrix(m) {
      for (var i = 0, l = this.count; i < l; i++) {
        _vector$6.fromBufferAttribute(this, i);
        _vector$6.applyNormalMatrix(m);
        this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
      }
      return this;
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(m) {
      for (var i = 0, l = this.count; i < l; i++) {
        _vector$6.fromBufferAttribute(this, i);
        _vector$6.transformDirection(m);
        this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
      }
      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(index, component) {
      var value = this.array[index * this.data.stride + this.offset + component];
      if (this.normalized) value = denormalize(value, this.array);
      return value;
    }
  }, {
    key: "setComponent",
    value: function setComponent(index, component, value) {
      if (this.normalized) value = normalize(value, this.array);
      this.data.array[index * this.data.stride + this.offset + component] = value;
      return this;
    }
  }, {
    key: "setX",
    value: function setX(index, x) {
      if (this.normalized) x = normalize(x, this.array);
      this.data.array[index * this.data.stride + this.offset] = x;
      return this;
    }
  }, {
    key: "setY",
    value: function setY(index, y) {
      if (this.normalized) y = normalize(y, this.array);
      this.data.array[index * this.data.stride + this.offset + 1] = y;
      return this;
    }
  }, {
    key: "setZ",
    value: function setZ(index, z) {
      if (this.normalized) z = normalize(z, this.array);
      this.data.array[index * this.data.stride + this.offset + 2] = z;
      return this;
    }
  }, {
    key: "setW",
    value: function setW(index, w) {
      if (this.normalized) w = normalize(w, this.array);
      this.data.array[index * this.data.stride + this.offset + 3] = w;
      return this;
    }
  }, {
    key: "getX",
    value: function getX(index) {
      var x = this.data.array[index * this.data.stride + this.offset];
      if (this.normalized) x = denormalize(x, this.array);
      return x;
    }
  }, {
    key: "getY",
    value: function getY(index) {
      var y = this.data.array[index * this.data.stride + this.offset + 1];
      if (this.normalized) y = denormalize(y, this.array);
      return y;
    }
  }, {
    key: "getZ",
    value: function getZ(index) {
      var z = this.data.array[index * this.data.stride + this.offset + 2];
      if (this.normalized) z = denormalize(z, this.array);
      return z;
    }
  }, {
    key: "getW",
    value: function getW(index) {
      var w = this.data.array[index * this.data.stride + this.offset + 3];
      if (this.normalized) w = denormalize(w, this.array);
      return w;
    }
  }, {
    key: "setXY",
    value: function setXY(index, x, y) {
      index = index * this.data.stride + this.offset;
      if (this.normalized) {
        x = normalize(x, this.array);
        y = normalize(y, this.array);
      }
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      return this;
    }
  }, {
    key: "setXYZ",
    value: function setXYZ(index, x, y, z) {
      index = index * this.data.stride + this.offset;
      if (this.normalized) {
        x = normalize(x, this.array);
        y = normalize(y, this.array);
        z = normalize(z, this.array);
      }
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      this.data.array[index + 2] = z;
      return this;
    }
  }, {
    key: "setXYZW",
    value: function setXYZW(index, x, y, z, w) {
      index = index * this.data.stride + this.offset;
      if (this.normalized) {
        x = normalize(x, this.array);
        y = normalize(y, this.array);
        z = normalize(z, this.array);
        w = normalize(w, this.array);
      }
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      this.data.array[index + 2] = z;
      this.data.array[index + 3] = w;
      return this;
    }
  }, {
    key: "clone",
    value: function clone(data) {
      if (data === undefined) {
        console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.');
        var array = [];
        for (var i = 0; i < this.count; i++) {
          var index = i * this.data.stride + this.offset;
          for (var j = 0; j < this.itemSize; j++) {
            array.push(this.data.array[index + j]);
          }
        }
        return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
      } else {
        if (data.interleavedBuffers === undefined) {
          data.interleavedBuffers = {};
        }
        if (data.interleavedBuffers[this.data.uuid] === undefined) {
          data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
        }
        return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON(data) {
      if (data === undefined) {
        console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.');
        var array = [];
        for (var i = 0; i < this.count; i++) {
          var index = i * this.data.stride + this.offset;
          for (var j = 0; j < this.itemSize; j++) {
            array.push(this.data.array[index + j]);
          }
        }

        // de-interleave data and save it as an ordinary buffer attribute for now

        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: array,
          normalized: this.normalized
        };
      } else {
        // save as true interleaved attribute

        if (data.interleavedBuffers === undefined) {
          data.interleavedBuffers = {};
        }
        if (data.interleavedBuffers[this.data.uuid] === undefined) {
          data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
        }
        return {
          isInterleavedBufferAttribute: true,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized
        };
      }
    }
  }]);
  return InterleavedBufferAttribute;
}();
var FramebufferTexture = /*#__PURE__*/function (_Texture2) {
  _inherits(FramebufferTexture, _Texture2);
  var _super16 = _createSuper(FramebufferTexture);
  function FramebufferTexture(width, height) {
    var _this13;
    _classCallCheck(this, FramebufferTexture);
    _this13 = _super16.call(this, {
      width: width,
      height: height
    });
    _this13.isFramebufferTexture = true;
    _this13.magFilter = NearestFilter;
    _this13.minFilter = NearestFilter;
    _this13.generateMipmaps = false;
    _this13.needsUpdate = true;
    return _this13;
  }
  return _createClass(FramebufferTexture);
}(Texture);
var RawShaderMaterial = /*#__PURE__*/function (_ShaderMaterial) {
  _inherits(RawShaderMaterial, _ShaderMaterial);
  var _super17 = _createSuper(RawShaderMaterial);
  function RawShaderMaterial(parameters) {
    var _this14;
    _classCallCheck(this, RawShaderMaterial);
    _this14 = _super17.call(this, parameters);
    _this14.isRawShaderMaterial = true;
    _this14.type = 'RawShaderMaterial';
    return _this14;
  }
  return _createClass(RawShaderMaterial);
}(ShaderMaterial);
var Cache = {
  enabled: false,
  files: {},
  add: function add(key, file) {
    if (this.enabled === false) return;

    // console.log( 'THREE.Cache', 'Adding key:', key );

    this.files[key] = file;
  },
  get: function get(key) {
    if (this.enabled === false) return;

    // console.log( 'THREE.Cache', 'Checking key:', key );

    return this.files[key];
  },
  remove: function remove(key) {
    delete this.files[key];
  },
  clear: function clear() {
    this.files = {};
  }
};
var LoadingManager = /*#__PURE__*/_createClass(function LoadingManager(onLoad, onProgress, onError) {
  _classCallCheck(this, LoadingManager);
  var scope = this;
  var isLoading = false;
  var itemsLoaded = 0;
  var itemsTotal = 0;
  var urlModifier = undefined;
  var handlers = [];

  // Refer to #5689 for the reason why we don't set .onStart
  // in the constructor

  this.onStart = undefined;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;
  this.itemStart = function (url) {
    itemsTotal++;
    if (isLoading === false) {
      if (scope.onStart !== undefined) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }
    isLoading = true;
  };
  this.itemEnd = function (url) {
    itemsLoaded++;
    if (scope.onProgress !== undefined) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }
    if (itemsLoaded === itemsTotal) {
      isLoading = false;
      if (scope.onLoad !== undefined) {
        scope.onLoad();
      }
    }
  };
  this.itemError = function (url) {
    if (scope.onError !== undefined) {
      scope.onError(url);
    }
  };
  this.resolveURL = function (url) {
    if (urlModifier) {
      return urlModifier(url);
    }
    return url;
  };
  this.setURLModifier = function (transform) {
    urlModifier = transform;
    return this;
  };
  this.addHandler = function (regex, loader) {
    handlers.push(regex, loader);
    return this;
  };
  this.removeHandler = function (regex) {
    var index = handlers.indexOf(regex);
    if (index !== -1) {
      handlers.splice(index, 2);
    }
    return this;
  };
  this.getHandler = function (file) {
    for (var i = 0, l = handlers.length; i < l; i += 2) {
      var regex = handlers[i];
      var loader = handlers[i + 1];
      if (regex.global) regex.lastIndex = 0; // see #17920

      if (regex.test(file)) {
        return loader;
      }
    }
    return null;
  };
});
var DefaultLoadingManager = /*@__PURE__*/new LoadingManager();
var Loader = /*#__PURE__*/function () {
  function Loader(manager) {
    _classCallCheck(this, Loader);
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    this.crossOrigin = 'anonymous';
    this.withCredentials = false;
    this.path = '';
    this.resourcePath = '';
    this.requestHeader = {};
  }
  _createClass(Loader, [{
    key: "load",
    value: function load( /* url, onLoad, onProgress, onError */) {}
  }, {
    key: "loadAsync",
    value: function loadAsync(url, onProgress) {
      var scope = this;
      return new Promise(function (resolve, reject) {
        scope.load(url, resolve, onProgress, reject);
      });
    }
  }, {
    key: "parse",
    value: function parse( /* data */) {}
  }, {
    key: "setCrossOrigin",
    value: function setCrossOrigin(crossOrigin) {
      this.crossOrigin = crossOrigin;
      return this;
    }
  }, {
    key: "setWithCredentials",
    value: function setWithCredentials(value) {
      this.withCredentials = value;
      return this;
    }
  }, {
    key: "setPath",
    value: function setPath(path) {
      this.path = path;
      return this;
    }
  }, {
    key: "setResourcePath",
    value: function setResourcePath(resourcePath) {
      this.resourcePath = resourcePath;
      return this;
    }
  }, {
    key: "setRequestHeader",
    value: function setRequestHeader(requestHeader) {
      this.requestHeader = requestHeader;
      return this;
    }
  }]);
  return Loader;
}();
Loader.DEFAULT_MATERIAL_NAME = '__DEFAULT';
var ImageLoader = /*#__PURE__*/function (_Loader) {
  _inherits(ImageLoader, _Loader);
  var _super18 = _createSuper(ImageLoader);
  function ImageLoader(manager) {
    _classCallCheck(this, ImageLoader);
    return _super18.call(this, manager);
  }
  _createClass(ImageLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      if (this.path !== undefined) url = this.path + url;
      url = this.manager.resolveURL(url);
      var scope = this;
      var cached = Cache.get(url);
      if (cached !== undefined) {
        scope.manager.itemStart(url);
        setTimeout(function () {
          if (onLoad) onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      var image = createElementNS('img');
      function onImageLoad() {
        removeEventListeners();
        Cache.add(url, this);
        if (onLoad) onLoad(this);
        scope.manager.itemEnd(url);
      }
      function onImageError(event) {
        removeEventListeners();
        if (onError) onError(event);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }
      function removeEventListeners() {
        image.removeEventListener('load', onImageLoad, false);
        image.removeEventListener('error', onImageError, false);
      }
      image.addEventListener('load', onImageLoad, false);
      image.addEventListener('error', onImageError, false);
      if (url.slice(0, 5) !== 'data:') {
        if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
      }
      scope.manager.itemStart(url);
      image.src = url;
      return image;
    }
  }]);
  return ImageLoader;
}(Loader);
var TextureLoader = /*#__PURE__*/function (_Loader2) {
  _inherits(TextureLoader, _Loader2);
  var _super19 = _createSuper(TextureLoader);
  function TextureLoader(manager) {
    _classCallCheck(this, TextureLoader);
    return _super19.call(this, manager);
  }
  _createClass(TextureLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var texture = new Texture();
      var loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setPath(this.path);
      loader.load(url, function (image) {
        texture.image = image;
        texture.needsUpdate = true;
        if (onLoad !== undefined) {
          onLoad(texture);
        }
      }, onProgress, onError);
      return texture;
    }
  }]);
  return TextureLoader;
}(Loader);
var Light = /*#__PURE__*/function (_Object3D4) {
  _inherits(Light, _Object3D4);
  var _super20 = _createSuper(Light);
  function Light(color) {
    var _this15;
    var intensity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    _classCallCheck(this, Light);
    _this15 = _super20.call(this);
    _this15.isLight = true;
    _this15.type = 'Light';
    _this15.color = new Color(color);
    _this15.intensity = intensity;
    return _this15;
  }
  _createClass(Light, [{
    key: "dispose",
    value: function dispose() {

      // Empty here in base class; some subclasses override.
    }
  }, {
    key: "copy",
    value: function copy(source, recursive) {
      _get(_getPrototypeOf(Light.prototype), "copy", this).call(this, source, recursive);
      this.color.copy(source.color);
      this.intensity = source.intensity;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _get(_getPrototypeOf(Light.prototype), "toJSON", this).call(this, meta);
      data.object.color = this.color.getHex();
      data.object.intensity = this.intensity;
      if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
      if (this.distance !== undefined) data.object.distance = this.distance;
      if (this.angle !== undefined) data.object.angle = this.angle;
      if (this.decay !== undefined) data.object.decay = this.decay;
      if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
      if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
      return data;
    }
  }]);
  return Light;
}(Object3D);
var _projScreenMatrix$1 = /*@__PURE__*/new Matrix4();
var _lightPositionWorld$1 = /*@__PURE__*/new Vector3();
var _lookTarget$1 = /*@__PURE__*/new Vector3();
var LightShadow = /*#__PURE__*/function () {
  function LightShadow(camera) {
    _classCallCheck(this, LightShadow);
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [new Vector4(0, 0, 1, 1)];
  }
  _createClass(LightShadow, [{
    key: "getViewportCount",
    value: function getViewportCount() {
      return this._viewportCount;
    }
  }, {
    key: "getFrustum",
    value: function getFrustum() {
      return this._frustum;
    }
  }, {
    key: "updateMatrices",
    value: function updateMatrices(light) {
      var shadowCamera = this.camera;
      var shadowMatrix = this.matrix;
      _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
      shadowCamera.position.copy(_lightPositionWorld$1);
      _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
      shadowCamera.lookAt(_lookTarget$1);
      shadowCamera.updateMatrixWorld();
      _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
      this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
      shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
      shadowMatrix.multiply(_projScreenMatrix$1);
    }
  }, {
    key: "getViewport",
    value: function getViewport(viewportIndex) {
      return this._viewports[viewportIndex];
    }
  }, {
    key: "getFrameExtents",
    value: function getFrameExtents() {
      return this._frameExtents;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.map) {
        this.map.dispose();
      }
      if (this.mapPass) {
        this.mapPass.dispose();
      }
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.camera = source.camera.clone();
      this.bias = source.bias;
      this.radius = source.radius;
      this.mapSize.copy(source.mapSize);
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var object = {};
      if (this.bias !== 0) object.bias = this.bias;
      if (this.normalBias !== 0) object.normalBias = this.normalBias;
      if (this.radius !== 1) object.radius = this.radius;
      if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
      object.camera = this.camera.toJSON(false).object;
      delete object.camera.matrix;
      return object;
    }
  }]);
  return LightShadow;
}();
var _projScreenMatrix = /*@__PURE__*/new Matrix4();
var _lightPositionWorld = /*@__PURE__*/new Vector3();
var _lookTarget = /*@__PURE__*/new Vector3();
var PointLightShadow = /*#__PURE__*/function (_LightShadow) {
  _inherits(PointLightShadow, _LightShadow);
  var _super21 = _createSuper(PointLightShadow);
  function PointLightShadow() {
    var _this16;
    _classCallCheck(this, PointLightShadow);
    _this16 = _super21.call(this, new PerspectiveCamera(90, 1, 0.5, 500));
    _this16.isPointLightShadow = true;
    _this16._frameExtents = new Vector2(4, 2);
    _this16._viewportCount = 6;
    _this16._viewports = [
    // These viewports map a cube-map onto a 2D texture with the
    // following orientation:
    //
    //  xzXZ
    //   y Y
    //
    // X - Positive x direction
    // x - Negative x direction
    // Y - Positive y direction
    // y - Negative y direction
    // Z - Positive z direction
    // z - Negative z direction

    // positive X
    new Vector4(2, 1, 1, 1),
    // negative X
    new Vector4(0, 1, 1, 1),
    // positive Z
    new Vector4(3, 1, 1, 1),
    // negative Z
    new Vector4(1, 1, 1, 1),
    // positive Y
    new Vector4(3, 0, 1, 1),
    // negative Y
    new Vector4(1, 0, 1, 1)];
    _this16._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
    _this16._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
    return _this16;
  }
  _createClass(PointLightShadow, [{
    key: "updateMatrices",
    value: function updateMatrices(light) {
      var viewportIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var camera = this.camera;
      var shadowMatrix = this.matrix;
      var far = light.distance || camera.far;
      if (far !== camera.far) {
        camera.far = far;
        camera.updateProjectionMatrix();
      }
      _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
      camera.position.copy(_lightPositionWorld);
      _lookTarget.copy(camera.position);
      _lookTarget.add(this._cubeDirections[viewportIndex]);
      camera.up.copy(this._cubeUps[viewportIndex]);
      camera.lookAt(_lookTarget);
      camera.updateMatrixWorld();
      shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
      _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      this._frustum.setFromProjectionMatrix(_projScreenMatrix);
    }
  }]);
  return PointLightShadow;
}(LightShadow);
var PointLight = /*#__PURE__*/function (_Light) {
  _inherits(PointLight, _Light);
  var _super22 = _createSuper(PointLight);
  function PointLight(color, intensity) {
    var _this17;
    var distance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var decay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;
    _classCallCheck(this, PointLight);
    _this17 = _super22.call(this, color, intensity);
    _this17.isPointLight = true;
    _this17.type = 'PointLight';
    _this17.distance = distance;
    _this17.decay = decay;
    _this17.shadow = new PointLightShadow();
    return _this17;
  }
  _createClass(PointLight, [{
    key: "power",
    get: function get() {
      // compute the light's luminous power (in lumens) from its intensity (in candela)
      // for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)
      return this.intensity * 4 * Math.PI;
    },
    set: function set(power) {
      // set the light's intensity (in candela) from the desired luminous power (in lumens)
      this.intensity = power / (4 * Math.PI);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.shadow.dispose();
    }
  }, {
    key: "copy",
    value: function copy(source, recursive) {
      _get(_getPrototypeOf(PointLight.prototype), "copy", this).call(this, source, recursive);
      this.distance = source.distance;
      this.decay = source.decay;
      this.shadow = source.shadow.clone();
      return this;
    }
  }]);
  return PointLight;
}(Light);
var _vector$4 = /*@__PURE__*/new Vector2();
var Box2 = /*#__PURE__*/function () {
  function Box2() {
    var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2(+Infinity, +Infinity);
    var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2(-Infinity, -Infinity);
    _classCallCheck(this, Box2);
    this.isBox2 = true;
    this.min = min;
    this.max = max;
  }
  _createClass(Box2, [{
    key: "set",
    value: function set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    }
  }, {
    key: "setFromPoints",
    value: function setFromPoints(points) {
      this.makeEmpty();
      for (var i = 0, il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }
      return this;
    }
  }, {
    key: "setFromCenterAndSize",
    value: function setFromCenterAndSize(center, size) {
      var halfSize = _vector$4.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
  }, {
    key: "makeEmpty",
    value: function makeEmpty() {
      this.min.x = this.min.y = +Infinity;
      this.max.x = this.max.y = -Infinity;
      return this;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

      return this.max.x < this.min.x || this.max.y < this.min.y;
    }
  }, {
    key: "getCenter",
    value: function getCenter(target) {
      return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
  }, {
    key: "getSize",
    value: function getSize(target) {
      return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
    }
  }, {
    key: "expandByPoint",
    value: function expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
  }, {
    key: "expandByVector",
    value: function expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
  }, {
    key: "expandByScalar",
    value: function expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
    }
  }, {
    key: "containsBox",
    value: function containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
    }
  }, {
    key: "getParameter",
    value: function getParameter(point, target) {
      // This can potentially have a divide by zero if the box
      // has a size dimension of 0.

      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      // using 4 splitting planes to rule out intersections

      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
    }
  }, {
    key: "clampPoint",
    value: function clampPoint(point, target) {
      return target.copy(point).clamp(this.min, this.max);
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point) {
      return this.clampPoint(point, _vector$4).distanceTo(point);
    }
  }, {
    key: "intersect",
    value: function intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      if (this.isEmpty()) this.makeEmpty();
      return this;
    }
  }, {
    key: "union",
    value: function union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
  }, {
    key: "equals",
    value: function equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  }]);
  return Box2;
}();
if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
    detail: {
      revision: REVISION
    }
  }));
}
if (typeof window !== 'undefined') {
  if (window.__THREE__) {
    console.warn('WARNING: Multiple instances of Three.js being imported.');
  } else {
    window.__THREE__ = REVISION;
  }
}
export { AddEquation, AdditiveBlending, AlwaysStencilFunc, BackSide, Box2, Box3, BufferAttribute, BufferGeometry, Cache, Camera, ClampToEdgeWrapping, Color, ColorManagement, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DisplayP3ColorSpace, Euler, EventDispatcher, Float32BufferAttribute, FloatType, FramebufferTexture, FrontSide, Frustum, Group, ImageLoader, ImageUtils, InterleavedBuffer, InterleavedBufferAttribute, KeepStencilOp, Layers, LessEqualCompare, LessEqualDepth, Light, LinearDisplayP3ColorSpace, LinearEncoding, LinearFilter, LinearMipmapLinearFilter, LinearSRGBColorSpace, LinearTransfer, Loader, LoadingManager, Material, Matrix3, Matrix4, Mesh, MeshBasicMaterial, MirroredRepeatWrapping, MultiplyOperation, NearestFilter, NoColorSpace, NormalBlending, Object3D, OneMinusSrcAlphaFactor, P3Primaries, PerspectiveCamera, Plane, PlaneGeometry, PointLight, Quaternion, REVISION, RGBAFormat, RawShaderMaterial, Ray, Rec709Primaries, RepeatWrapping, SRGBColorSpace, SRGBTransfer, ShaderMaterial, Source, Sphere, SrcAlphaFactor, StaticDrawUsage, Texture, TextureLoader, Triangle, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, UnsignedByteType, UnsignedInt248Type, UnsignedIntType, Vector2, Vector3, Vector4, WebGLCoordinateSystem, WebGPUCoordinateSystem, sRGBEncoding };
//# sourceMappingURL=three.module.js.map
